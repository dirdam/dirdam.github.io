<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Squadro setter</title>
		<meta name="Author" content="Adrián Jiménez Pascual">
	    <link rel="canonical" href="https://dirdam.github.io">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black">
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<!-- <link rel="preload" as="style" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" onload="this.rel='stylesheet'"> -->
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
		
		<link rel="shortcut icon" href="../../images/lasso_logo.ico"/>
		<link href="styles.css" media='all' rel='stylesheet'/>
	</head>

<body>
	<div id="setter_menu">
		<table>
			<tbody>
				<tr>
					<td colspan="11">Set Squadro's board layout.</td>
				</tr>
				<tr>
					<th class="direction"></th>
					<th colspan="10" class="header">Position</th>
				</tr>
				<tr>
					<th class="direction">Reds</th>
					<td>0</td>
					<td>|</td>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					<td>5</td>
					<td>|</td>
					<td>6</td>
				</tr>
				<tr>
					<td class="direction">
						<label>R5</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_R5">
							<span class="slider round red"></span>
						</label>
						<label>S5</label>
					</td>
					<td><input type="radio" class="red" name="R5" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R5" value="1"></td>
					<td><input type="radio" class="red" name="R5" value="2"></td>
					<td><input type="radio" class="red" name="R5" value="3"></td>
					<td><input type="radio" class="red" name="R5" value="4"></td>
					<td><input type="radio" class="red" name="R5" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R5" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>R4</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_R4">
							<span class="slider round red"></span>
						</label>
						<label>S4</label>
					</td>
					<td><input type="radio" class="red" name="R4" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R4" value="1"></td>
					<td><input type="radio" class="red" name="R4" value="2"></td>
					<td><input type="radio" class="red" name="R4" value="3"></td>
					<td><input type="radio" class="red" name="R4" value="4"></td>
					<td><input type="radio" class="red" name="R4" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R4" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>R3</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_R3">
							<span class="slider round red"></span>
						</label>
						<label>S3</label>
					</td>
					<td><input type="radio" class="red" name="R3" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R3" value="1"></td>
					<td><input type="radio" class="red" name="R3" value="2"></td>
					<td><input type="radio" class="red" name="R3" value="3"></td>
					<td><input type="radio" class="red" name="R3" value="4"></td>
					<td><input type="radio" class="red" name="R3" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R3" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>R2</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_R2">
							<span class="slider round red"></span>
						</label>
						<label>S2</label>
					</td>
					<td><input type="radio" class="red" name="R2" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R2" value="1"></td>
					<td><input type="radio" class="red" name="R2" value="2"></td>
					<td><input type="radio" class="red" name="R2" value="3"></td>
					<td><input type="radio" class="red" name="R2" value="4"></td>
					<td><input type="radio" class="red" name="R2" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R2" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>R1</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_R1">
							<span class="slider round red"></span>
						</label>
						<label>S1</label>
					</td>
					<td><input type="radio" class="red" name="R1" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R1" value="1"></td>
					<td><input type="radio" class="red" name="R1" value="2"></td>
					<td><input type="radio" class="red" name="R1" value="3"></td>
					<td><input type="radio" class="red" name="R1" value="4"></td>
					<td><input type="radio" class="red" name="R1" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="red" name="R1" value="6"></td>
				</tr>
				<tr>
					<td colspan="11" class="header"></td>
				</tr>
				<tr>
					<th class="direction">Yellows</th>
					<td>0</td>
					<td>|</td>
					<td>1</td>
					<td>2</td>
					<td>3</td>
					<td>4</td>
					<td>5</td>
					<td>|</td>
					<td>6</td>
				</tr>
				<tr>
					<td class="direction">
						<label>Y1</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_Y1">
							<span class="slider round yellow"></span>
						</label>
						<label>Z1</label>
					</td>
					<td><input type="radio" class="yellow" name="Y1" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y1" value="1"></td>
					<td><input type="radio" class="yellow" name="Y1" value="2"></td>
					<td><input type="radio" class="yellow" name="Y1" value="3"></td>
					<td><input type="radio" class="yellow" name="Y1" value="4"></td>
					<td><input type="radio" class="yellow" name="Y1" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y1" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>Y2</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_Y2">
							<span class="slider round yellow"></span>
						</label>
						<label>Z2</label>
					</td>
					<td><input type="radio" class="yellow" name="Y2" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y2" value="1"></td>
					<td><input type="radio" class="yellow" name="Y2" value="2"></td>
					<td><input type="radio" class="yellow" name="Y2" value="3"></td>
					<td><input type="radio" class="yellow" name="Y2" value="4"></td>
					<td><input type="radio" class="yellow" name="Y2" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y2" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>Y3</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_Y3">
							<span class="slider round yellow"></span>
						</label>
						<label>Z3</label>
					</td>
					<td><input type="radio" class="yellow" name="Y3" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y3" value="1"></td>
					<td><input type="radio" class="yellow" name="Y3" value="2"></td>
					<td><input type="radio" class="yellow" name="Y3" value="3"></td>
					<td><input type="radio" class="yellow" name="Y3" value="4"></td>
					<td><input type="radio" class="yellow" name="Y3" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y3" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>Y4</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_Y4">
							<span class="slider round yellow"></span>
						</label>
						<label>Z4</label>
					</td>
					<td><input type="radio" class="yellow" name="Y4" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y4" value="1"></td>
					<td><input type="radio" class="yellow" name="Y4" value="2"></td>
					<td><input type="radio" class="yellow" name="Y4" value="3"></td>
					<td><input type="radio" class="yellow" name="Y4" value="4"></td>
					<td><input type="radio" class="yellow" name="Y4" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y4" value="6"></td>
				</tr>
				<tr>
					<td class="direction">
						<label>Y5</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_Y5">
							<span class="slider round yellow"></span>
						</label>
						<label>Z5</label>
					</td>
					<td><input type="radio" class="yellow" name="Y5" value="0" checked="true"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y5" value="1"></td>
					<td><input type="radio" class="yellow" name="Y5" value="2"></td>
					<td><input type="radio" class="yellow" name="Y5" value="3"></td>
					<td><input type="radio" class="yellow" name="Y5" value="4"></td>
					<td><input type="radio" class="yellow" name="Y5" value="5"></td>
					<td>|</td>
					<td><input type="radio" class="yellow" name="Y5" value="6"></td>
				</tr>
				<tr>
					<td colspan="11" class="header"></td>
				</tr>
				<tr>
					<th class="direction">Next turn</th>
					<th colspan="10"></th>
				</tr>
				<tr>
					<td class="direction">
						<label>R</label>
						<label class="switch">
							<input type="checkbox" id="checkbox_turn">
							<span class="slider round turn"></span>
						</label>
						<label>Y</label>
					</td>
					<th colspan="10"><button type="button" onclick="htmlToCode()"><b>Load board</b></button></th>
				</tr>
			</tbody>
		</table>
		<br>
	</div>
</body>

<script>
//l1b2l1b3l3b1l3b1l3b2l3b1l1b3l1b1l1b3l1b1l1b1l1b3l3b2l1b1l3b2l1b3l3
console.log("?code=l0l0l0l0l0r0r0r0r0r0&turn=l\nLeft:  'l' for going 'L' for coming\nRight: 'r' for going 'R' for coming\nNumbering in the normal reference system\nTurn always 'l' or 'r'");
//Color variables
var background_color = "white";
var copyright_color = "rgb(50,50,50)";
var players_colors = ["rgb(140,0,0)", "rgb(255,160,0)"]; //Currently used colors
var players_border_colors = ["rgb(70,0,0)", "rgb(127,80,0)"]; //Currently used colors
var players_backbone_colors = ["rgb(170,0,0)", "rgb(255,180,0)"]; //Currently used colors
var colors_display = ["red", "orange", "yellow", "limegreen", "turquoise", "blue", "violetred"/*, "ivory", "black"*/]; //These are all the colors
var aura_color = "rgb(255,205,0)"; //Color of the aura of the surounding circle of choice in settings
var board_color = "rgb(50,50,50)"; //Board color
var color_player = 0; //Player whose color is being determined
var show_advantage = false; //Show advantage not a choice; only shown in replay
var chosen_color = 0; //Used in settings menu
var chosen_turn = 2; //Selection of first turn (0, 1, 2 (random))
var adv_red = "rgb(205,38,38)", adv_green = "green"; //Color of the advantages
var colors_before_replay = players_colors; //Saves colors before replay

//Buttons variables
var replay_screen_proportions = [1/2, 1, 1]; //[,*,]: 1: up-left; -1: down-right; [,,*]: 1: show; 0: hide
var settings_screen_proportions = [1/3, -1, 1]; //[,*,]: 1: up-left; -1: down-right; [,,*]: 1: show; 0: hide
var help_screen_proportions = [2/3, 1, 0]; //[,*,]: 1: up-left; -1: down-right; [,,*]: 1: show; 0: hide
var notice_screen_proportions = [2/3, -1, 1]; //[,*,]: 1: up-left; -1: down-right; [,,*]: 1: show; 0: hide

var exit_margin = 10;
var exit_font_size = innerHeight/20;
var adv_button_width; //Width of the advance and go back buttons

var board_margin = 0; // Proportion with respect to sq_length for board external margin // RESIZE

//Global variables
var menu = 0; //0: sizes; 1: rival; 2: level; 3: board; 4: settings; 5: replay; 6: help; 7: notice
var board_size; //Size of the board
var bot_chosen; //Bot or not
var bot; //Bot itself
var turn, best_player; // turn; player whose overall moves_to_finish are less
var player = new Array(2); //Inlcudes the 2 players, each with board_size pieces
var SPEEDS = {'3': {'left': [1, 2, 1], 'bottom': [2, 1, 2]}, '5': {'left': [1, 3, 2, 3, 1], 'bottom':[3, 1, 2, 1, 3]}};
var side; //Side to play when playing against bot

var min, margin_x, margin_y, sq_length; //Least of sides; difference x; difference y; board's square length

//Memory variables
var board_record = new Array(); //Records all boards of one game. LAST ENTRY is only the player who won (single number)
var board_records = new Array(); //Records all games
var current_state = new Array(2); //Current pieces of the game (used to load last hand, for if one wants to go back)
var replay = null; //Saves the board_record to be replayed. Includes board_record and players_colors
var replay_step = 0;

//Temporary states of the game
var speak = [false, false, false, false]; //[spar, fratama, bitya, asta]
var text_time = 500; //Time displaying the voices
var response_time = 500; //Time for bot to think (500 for normal)
var logo_time = 2000; //Time to draw logo


/**** PIECE DEFINITION & METHODS ****/

var Piece = function(player, x, y, value) {
	this.player = player; //0 or 1
	this.x = x; //0 ~ board_size + 1
	this.y = y; //0 ~ board_size + 1
	this.value = value; //Value
	this.second_value = Math.floor(board_size/2) - this.value + (board_size%2 == 0 ? 1 : 2); //Second value
	this.next_advance = value; //Next REAL value to advance
	this.direction = 1; //1: go; -1: come
	this.end = false; //Finished or not

	this.moves_to_finish = Math.floor((board_size + 1)/this.value) + ((board_size + 1)%this.value == 0 ? 0 : 1) + Math.floor((board_size + 1)/this.second_value) + ((board_size + 1)%this.second_value == 0 ? 0 : 1); //Considering eating all in between to the end
	//this.lane = 0; //0 ~ 2*(board_size + 1). Real position of the advance
	//this.reach_lane = (this.player == 0 ? board_size + 1 - this.y : this.x); //Lane where it moves (with respect to the rival)
}

Piece.prototype.draw = function(bot) {
	context.globalAlpha = (this.end ? 0.1 : 1);
	var w = canvas.width;
	var h = canvas.height;
	var board_length = min - 2*sq_length;
	var tile_length = sq_length;
	var size = board_size;
	var agent_id = (this.player == 0 ? "left" : "bottom");
	var direction = this.direction;
	var x = (agent_id == "left" ? this.x : this.x - 1);
	var y = (agent_id == "left" ? this.y - 1 : board_size + 1 - this.y);
	context.fillStyle = players_colors[(agent_id == "left" ? 0 : 1)];
	context.strokeStyle = players_border_colors[(agent_id == "left" ? 0 : 1)];
	context.lineWidth = 1;
	var ori_hv = (agent_id == "left" ? 1 : -1);
	if (agent_id == "bottom") y = size + 1 - y;
	x = w/2 - board_length/2 + (x+0.5)*tile_length - (agent_id == "left" ? 1 : 0)*tile_length; // RESIZE
	y = h/2 - board_length/2 + (y+0.5)*tile_length - (agent_id == "left" ? 0 : 1)*tile_length;; // RESIZE
	// Body
	if (bot) {
		context.strokeStyle = "antiquewhite";
		context.lineWidth = 3;
	}
	context.beginPath();
	context.rect(x - (ori_hv == 1 ? tile_length/2 - tile_length/6 : tile_length/6), y - (ori_hv == 1 ? tile_length/6 : tile_length/2 - tile_length/6), (ori_hv == 1 ? 2 : 1)*tile_length/3, (ori_hv == 1 ? 1 : 2)*tile_length/3);
	context.fill(); context.stroke();
	// Tip
	context.beginPath();
	context.moveTo(x + (ori_hv == 1 ? direction*tile_length/2 - direction*tile_length/6 : - tile_length/6), y - (ori_hv == 1 ? tile_length/6 : direction*tile_length/2 - direction*tile_length/6));
	context.lineTo(x + (ori_hv == 1 ? direction*tile_length/2 : 0), y - (ori_hv == 1 ? 0 : direction*tile_length/2));
	context.lineTo(x + (ori_hv == 1 ? direction*tile_length/2 - direction*tile_length/6 : tile_length/6), y - (ori_hv == 1 ? - tile_length/6 : direction*tile_length/2 - direction*tile_length/6));
	context.fill(); context.stroke();
	// Backbone
	context.strokeStyle = players_backbone_colors[(agent_id == "left" ? 0 : 1)];
	if (bot) {
		context.strokeStyle = "antiquewhite";
	}
	context.lineWidth = Math.max(2, tile_length/30);
	context.beginPath();
	context.moveTo(x - (ori_hv == 1 ? direction*(tile_length/2 - tile_length/6) : 0), y + (ori_hv == 1 ? 0 : direction*(tile_length/2 - tile_length/6)));
	context.lineTo(x + (ori_hv == 1 ? direction*(tile_length/2 - tile_length/6) : 0), y - (ori_hv == 1 ? 0 : direction*(tile_length/2 - tile_length/6)));
	context.stroke();
	context.lineWidth = 1;
	context.globalAlpha = 1;
}

Piece.prototype.move = function() { //Moves properly
	var eatables = this.calculateNextAdvance();
	if (this.player == 0) {
		this.x += this.next_advance*this.direction;
		if (this.x == board_size + 1) {
			this.direction = -1;
			this.value = this.second_value;
			speak[1] = true;
		}
		else if (this.x == 0 && this.direction == -1) {
			this.end = true;
			speak[2] = true;
		}
	}
	else {
		this.y -= this.next_advance*this.direction;
		if (this.y == 0) {
			this.direction = -1;
			this.value = this.second_value;
			speak[1] = true;
		}
		else if (this.y == board_size + 1 && this.direction == -1) {
			this.end = true;
			speak[2] = true;
		}
	}
	for (var i = 0; i < eatables.length; i++) {
		eatables[i].goHome();
		//eatables[i].updateLane();
		speak[0] = true;
	}
	//this.updateLane();
	this.directThreaten(1);
}

Piece.prototype.calculateNextAdvance = function() { //Updates next_advance and returns an array of pieces that will be eaten by this
	var i = 0; //Goes from 1 to the rest to finish that row/column (or the value limit)
	var found = false;
	var eaten = new Array();
	while (i < Math.min(this.value, 1 + (this.player == 0 ? (this.direction == 1 ? board_size - this.x : this.x - 1) : (this.direction == 1 ? this.y - 1 : board_size - this.y))) || found) {
		i++;
		var candidate = (this.player == 0 ? pieceOn(this.x + i*this.direction, this.y) : pieceOn(this.x, this.y - i*this.direction));
		if (candidate != null) { //If there is piece to be eaten
			found = true;
			eaten.push(candidate);
		}
		else { //If none can be eaten
			if (found) { //If already ate one
				break;
			}
		}
	}
	this.next_advance = i;
	return eaten;
}

Piece.prototype.goHome = function() { //Sends home this
	if (this.player == 0) {
		this.x = (this.direction == 1 ? 0 : board_size + 1);
	}
	else {
		this.y = (this.direction == 1 ? board_size + 1 : 0);
	}
}

Piece.prototype.reachesIn = function(coord) { //Returns how many moves this has to perform to reach the column/row "coord" (0 ~ board_size + 1). If coord is limit, update moves_to_finish
	var current_values = [this.x, this.y, this.next_advance, this.direction, this.value]; //Saves current values
	var i = 0;
	var num_eaten = 0; //Number of eaten pieces when going
	var eaten_places = new Array(); //Coordinates of the eaten pieces
	var second_lap = (this.player == 0 ? this.x >= coord : this.y <= coord) && this.direction == 1; //Going back required
	while (this.direction == 1 && (this.player == 0 ? (this.x < coord || (second_lap && this.x < board_size + 1)) : (this.y > coord || (second_lap && this.y > 0)))) { //While going
		var eaten = this.calculateNextAdvance();
		num_eaten += eaten.length; //These have to be leaped when coming
		for (var j = 0; j < eaten.length; j++) {
			eaten_places.push(this.player == 0 ? eaten[j].x : eaten[j].y);
		}
		if (this.player == 0) {
			this.x += this.next_advance;
			this.x = (this.x > board_size + 1 ? board_size + 1 : this.x);
		}
		else {
			this.y -= this.next_advance;
			this.y = (this.y < 0 ? 0 : this.y);
		}
		i++;
	}
	//Back
	if (((this.player == 0 ? this.x == board_size + 1 : this.y == 0) && second_lap) || this.direction == -1) { //Not found when going
		this.direction = -1;
		this.value = this.second_value;
		while ((this.player == 0 ? this.x > coord : this.y < coord)) { //While coming (for this purpose, "lane" must be greater than board_size + 1)
			var eaten = this.calculateNextAdvance();
			if (this.player == 0) {
				this.x -= (num_eaten == 0 ? this.next_advance : this.value); //Leap if necessary
				this.x = (this.x < 0 ? 0 : this.x);
			}
			else {
				this.y += (num_eaten == 0 ? this.next_advance : this.value);
				this.y = (this.y > board_size + 1 ? board_size + 1 : this.y);
			}
			for (var j = eaten_places.length - 1; j >= 0; j--) { //Leap
				if (this.player == 0) {
					if (this.x <= eaten_places[j]) {
						num_eaten -= 1;
						eaten_places.splice(j, 1);
					}
				}
				else {
					if (this.y >= eaten_places[j]) {
						num_eaten -= 1;
						eaten_places.splice(j, 1);
					}
				}
			}
			i++;
		}
	}
	this.x = current_values[0],	this.y = current_values[1],	this.next_advance = current_values[2],	this.direction = current_values[3],	this.value = current_values[4];
	if ((this.player == 0 ? coord == 0 : coord == board_size + 1)) { //If want to know moves to finish, update
		this.moves_to_finish = i;
	}
	return i;
}

Piece.prototype.calculateHomeAdvance = function() { //Returns an array of pieces that will be eaten by this if sent home
	var temp_x = this.x; var temp_y = this.y; //Start coordinates
	if (this.player == 0) {
		temp_x = (this.direction == 1 ? 0 : board_size + 1);
	}
	else {
		temp_y = (this.direction == 1 ? board_size + 1 : 0);
	}
	var i = 0; //Goes from 1 to the rest to finish that row/column (or the value limit)
	var found = false;
	var eaten = new Array();
	while (i < Math.min(this.value, 1 + (this.player == 0 ? (this.direction == 1 ? board_size - temp_x : temp_x - 1) : (this.direction == 1 ? temp_y - 1 : board_size - temp_y))) || found) {
		i++;
		var candidate = (this.player == 0 ? pieceOn(temp_x + i*this.direction, temp_y) : pieceOn(temp_x, temp_y - i*this.direction));
		if (candidate != null) { //If there is piece to be eaten
			found = true;
			eaten.push(candidate);
		}
		else { //If none can be eaten
			if (found) { //If already ate one
				break;
			}
		}
	}
	return eaten;
}
/*
Piece.prototype.neighbourhood = function() { //Returns an array of the neighbourhood of this coherent with board_record. Not in the neighbourhood will be stored as -1.
	var result = new Array(2);
	for (var i = 0; i < result.length; i++) {
		result[i] = new Array(board_size);
		for (var j = 0; j < result[i].length; j++) {
			result[i][j] = (i == this.player && j == player[i].indexOf(this) ? this.lane : -1); //Initialize the neighbourhood 
		}
	}
	//Add neighbours
	//If direct threaten, take this and the rest that will be eaten
	if (0 < this.x && this.x <= board_size && 0 < this.y && this.y <= board_size) { //Correct range
		var eatables = player[(this.player + 1)%2][(this.player == 0 ? this.x - 1 : this.y - 1)].calculateNextAdvance();
		if (eatables.indexOf(this) > -1) { //If this can be eaten
			//Add eaten pieces
			for (var i = 0; i < eatables.length; i++) {
				result[eatables[i].player][(eatables[i].player == 0 ? eatables[i].y - 1 : eatables[i].x - 1)] = player[eatables[i].player][(eatables[i].player == 0 ? eatables[i].y - 1 : eatables[i].x - 1)].lane;
			}
			//Add eater
			result[(this.player + 1)%2][(this.player == 0 ? this.x - 1 : this.y - 1)] = player[(this.player + 1)%2][(this.player == 0 ? this.x - 1: this.y - 1)].lane;
		}
	}
	//If next threaten, take next
	if (0 < this.x + this.direction*this.next_advance && this.x + this.direction*this.next_advance <= board_size && 0 < this.y - this.direction*this.next_advance && this.y - this.direction*this.next_advance <= board_size) { //Correct range
		if ((player[(this.player + 1)%2][(this.player == 0 ? this.x - 1 + this.direction*this.next_advance: this.y - 1 - this.direction*this.next_advance)].reachesIn(this.reach_lane) == 1) || (player[(this.player + 1)%2][(this.player == 0 ? this.x - 1 + this.direction*this.next_advance: this.y - 1 - this.direction*this.next_advance)].reachesIn(2*(board_size + 1) - this.reach_lane) == 1)) { //If next can be eaten
			result[(this.player + 1)%2][(this.player == 0 ? this.x - 1 + this.direction*this.next_advance: this.y - 1 - this.direction*this.next_advance)] = player[(this.player + 1)%2][(this.player == 0 ? this.x - 1 + this.direction*this.next_advance: this.y - 1 - this.direction*this.next_advance)].lane;
		}
	}
	//If eatables, take them too
	var eatables = this.calculateNextAdvance();
	for (var i = 0; i < eatables.length; i++) {
		result[(this.player + 1)%2][(this.player == 0 ? eatables[i].x - 1 : eatables[i].y - 1)] = eatables[i].lane;
		var reeatables = eatables[i].calculateNextAdvance(); //Eatables after the pieces not eaten
		for (var j = 0; j < reeatables.length; j++) {
			result[this.player][(this.player == 0 ? reeatables[j].y - 1 : reeatables[j].x - 1)] = reeatables[j].lane;
		}
		/*var reeatables = eatables[i].calculateHomeAdvance(); //Eatables after the pieces gone home
		for (var j = 0; j < reeatables.length; j++) {
			result[this.player][(this.player == 0 ? reeatables[j].y - 1 : reeatables[j].x - 1)] = reeatables[j].lane;
		}*
	}
	return result;
}

Piece.prototype.updateLane = function() { //Updates lane of this
	this.lane = (this.player == 0 ? (this.direction == 1 ? this.x : 2*(board_size + 1) - this.x) : (this.direction == 1 ? (board_size + 1 - this.y) : (board_size + 1 + this.y)));
}*/

Piece.prototype.directThreaten = function(value) { //Returns: 0: direct threaten; 1: direct next threaten
	this.calculateNextAdvance();
	var coord = (this.player == 0 ? this.x + this.direction*this.next_advance*value : this.y - this.direction*this.next_advance*value);
	var alt_coord = (this.player == 0 ? this.y : this.x);
	if (0 < coord && coord < board_size + 1) { //If this is reachable, return threat
		if (player[(this.player + 1)%2][coord - 1].reachesIn(alt_coord) == 1) {
			return player[(this.player + 1)%2][coord - 1];
		}
	}
}

Piece.prototype.longestSafe = function() { //Returns how many times this can move without being directly threatened (being next-threatened returns 0)

}

function loadCanvas() {
	//Environment
    canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    canvas.width = innerWidth; canvas.height = innerHeight;
    canvas.style.position = "absolute"; canvas.style.left = 0; canvas.style.top = 0;
    context = canvas.getContext("2d");

    min = Math.min(canvas.width, canvas.height);
    margin_x = (canvas.width - min)/2;
	margin_y = (canvas.height - min)/2;
	adv_button_width = min/12;
}

/**** DRAWING ALL SCREENS ****/

function drawLogo() { //Draws logo
	//Background
	context.fillStyle = background_color;
	context.fillRect(0, 0, canvas.width, canvas.height);
	var img = new Image();
	img.src = "../images/Squadro_theme.jpg";
	img.onload = function() {
		context.drawImage(img, margin_x, margin_y, min, min);
	};

	//Load font
	context.font = '900 1px "Font Awesome 5 Free"';
	context.fillText("", 0, 0);

	setTimeout(function() {
		decodeBoard();
	}, logo_time);
}

function drawSizes() { //Draws choose size, replay and settings
	drawBackground();
	context.lineWidth = 3;
	
	drawMiniBoard(canvas.width/3 - canvas.width/16, canvas.height/2, 3);
	drawMiniBoard(canvas.width*2/3 + canvas.width/16, canvas.height/2, 5);

	function drawMiniBoard(x, y, number) {
		var size = canvas.width/3;
		context.fillStyle = board_color;
		context.strokeStyle = "black";
		drawBorder(x, y, size, size/4);
		context.fill(); context.stroke();
		var thin = size/5;
		context.fillStyle = players_colors[0];
		context.strokeStyle = players_border_colors[0];
		context.beginPath();
		for (var i = 0; i < number; i++) {
			context.rect(x - size/2 + size/4 - thin, y - size/4 + i*(size/(2*number)) + (size/(2*number) - size/(2*number + 1))/2, thin, size/(2*number + 1));
		}
		context.fill(); context.stroke();
		context.fillStyle = players_colors[1];
		context.strokeStyle = players_border_colors[1];
		context.beginPath();
		for (var i = 0; i < number; i++) {
			context.rect(x - size/4 + i*(size/(2*number)) + (size/(2*number) - size/(2*number + 1))/2, y + size/2 - size/4, size/(2*number + 1), thin);
		}
		context.fill(); context.stroke();
	}

	function drawBorder(x, y, board_length, tile_length) {
		context.beginPath();
		context.moveTo(x - board_length/2 + tile_length/6 + tile_length/3, y - board_length/2 + tile_length/6);
		context.lineTo(x + board_length/2 - tile_length/6 - tile_length/3, y - board_length/2 + tile_length/6);
		context.arcTo(x + board_length/2 - tile_length/6, y - board_length/2 + tile_length/6, x + board_length/2 - tile_length/6, y - board_length/2 + tile_length/6 + tile_length/3, tile_length/3);
		context.lineTo(x + board_length/2 - tile_length/6, y + board_length/2 - tile_length/6 - tile_length/3);
		context.arcTo(x + board_length/2 - tile_length/6, y + board_length/2 - tile_length/6, x + board_length/2 - tile_length/6 - tile_length/3, y + board_length/2 - tile_length/6, tile_length/3);
		context.lineTo(x - board_length/2 + tile_length/6 + tile_length/3, y + board_length/2 - tile_length/6);
		context.arcTo(x - board_length/2 + tile_length/6, y + board_length/2 - tile_length/6, x - board_length/2 + tile_length/6, y + board_length/2 - tile_length/6 - tile_length/3, tile_length/3);
		context.lineTo(x - board_length/2 + tile_length/6, y - board_length/2 + tile_length/6 + tile_length/3);
		context.arcTo(x - board_length/2 + tile_length/6, y - board_length/2 + tile_length/6, x - board_length/2 + tile_length/6 + tile_length/3, y - board_length/2 + tile_length/6, tile_length/3);
	}
}

function drawRival() { //Draws VS PC or VS player
	drawBackground();
	context.fillStyle = board_color;
	context.strokeStyle = "black";
	context.font = "900 " + min/15 + 'px "Font Awesome 5 Free"';
	context.textBaseline = "middle";
	var text = "\uf0e7"; //Bolt
	context.fillText(text, canvas.width/4 - context.measureText(text).width/2, canvas.height/2);
	context.fillText(text, canvas.width*3/4 - context.measureText(text).width/2, canvas.height/2);
	context.font = "900 " + min/6 + 'px "Font Awesome 5 Free"';
	text = "\uf007"; //User
	context.fillStyle = players_colors[0];
	context.strokeStyle = players_border_colors[0];
	context.fillText(text, canvas.width*3/4 - canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	context.strokeText(text, canvas.width*3/4 - canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	context.fillStyle = players_colors[1];
	context.strokeStyle = players_border_colors[1];
	context.fillText(text, canvas.width*3/4 + canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	context.strokeText(text, canvas.width*3/4 + canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	var gradient = context.createLinearGradient(0, canvas.height*7/16, 0, canvas.height*9/16);
	gradient.addColorStop(0, players_colors[0]);
	gradient.addColorStop(1, players_colors[1]);
	var gradient2 = context.createLinearGradient(0, canvas.height*7/16, 0, canvas.height*9/16);
	gradient2.addColorStop(0, players_border_colors[0]);
	gradient2.addColorStop(1, players_border_colors[1]);
	context.fillStyle = gradient;
	context.strokeStyle = gradient2;
	context.fillText(text, canvas.width/4 - canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	context.strokeText(text, canvas.width/4 - canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	text = "\uf0a0"; //Chip
	context.fillText(text, canvas.width/4 + canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	context.strokeText(text, canvas.width/4 + canvas.width/8 - context.measureText(text).width/2, canvas.height/2);
	//Center line
	context.strokeStyle = "black";
	context.lineWidth = 3;
	context.beginPath();
	context.moveTo(canvas.width/2, 0);
	context.lineTo(canvas.width/2, canvas.height);
	context.stroke();

	//Exit button
	drawExitButton(0);
}

function drawLevel() { //Draws difficulty of bot (standard (algorithmic) or enhanced (memory))
	drawBackground();
	//Center line
	context.strokeStyle = "black";
	context.lineWidth = 3;
	context.beginPath();
	context.moveTo(canvas.width/2, 0);
	context.lineTo(canvas.width/2, canvas.height);
	context.stroke();
	
	context.font = "900 " + min/15 + 'px "Font Awesome 5 Free"';
	context.fillStyle = "gold";
	context.strokeStyle = "goldenrod";
	text = "\uf005"; //Star
	context.fillText(text, canvas.width/4 - context.measureText(text).width/2, canvas.height/2 - canvas.height/6);
	context.strokeText(text, canvas.width/4 - context.measureText(text).width/2, canvas.height/2 - canvas.height/6);
	text = "\uf005 \uf005"; //Star
	context.fillText(text, canvas.width*3/4 - context.measureText(text).width/2, canvas.height/2 - canvas.height/6);
	context.strokeText(text, canvas.width*3/4 - context.measureText(text).width/2, canvas.height/2 - canvas.height/6);
	context.font = "900 " + min/6 + 'px "Font Awesome 5 Free"';
	var gradient = context.createLinearGradient(0, canvas.height*7/16, 0, canvas.height*9/16);
	gradient.addColorStop(0, players_colors[0]);
	gradient.addColorStop(1, players_colors[1]);
	var gradient2 = context.createLinearGradient(0, canvas.height*7/16, 0, canvas.height*9/16);
	gradient2.addColorStop(0, players_border_colors[0]);
	gradient2.addColorStop(1, players_border_colors[1]);
	context.fillStyle = gradient;
	context.strokeStyle = gradient2;
	text = "\uf508"; //Tie
	context.fillText(text, canvas.width/4 - context.measureText(text).width/2, canvas.height/2);
	context.strokeText(text, canvas.width/4 - context.measureText(text).width/2, canvas.height/2);
	text = "\uf501"; //PhD
	context.fillText(text, canvas.width*3/4 - context.measureText(text).width/2, canvas.height/2);
	context.strokeText(text, canvas.width*3/4 - context.measureText(text).width/2, canvas.height/2);

	//Exit button
	drawExitButton(0);
}

function drawTurn(option) {
	drawBackground();
	context.strokeStyle = "black";
	context.lineWidth = 3;
	var text = (option == 0 ? "First hand" : "Your side");
	var divisions = (option == 0 ? 3 : 2);
	//Vertical lines
	for (var i = 0; i < divisions - 1; i++) {
		context.beginPath();
		context.moveTo(canvas.width*(i+1)/divisions, 0);
		context.lineTo(canvas.width*(i+1)/divisions, canvas.height);
		context.stroke();
	}
	//Header
	var font_size = min/15;
	context.fillStyle = background_color;
	var y = canvas.height/4;
	context.fillRect(0, y - font_size*2/3, canvas.width, font_size*4/3);
	context.fillStyle = "antiquewhite";
	context.font = font_size + "px Helvetica";
	context.textBaseline = "middle";
	context.strokeText(text, canvas.width/2 - context.measureText(text).width/2, y);
	context.fillText(text, canvas.width/2 - context.measureText(text).width/2, y);
	//Mini boards
	for (var i = 0; i < divisions; i++) {
		drawMiniBoard(canvas.width*(i+1)/divisions - canvas.width/(2*divisions), canvas.height/2, i);
	}

	function drawMiniBoard(x, y, choice) {
		var size = canvas.width/5;
		context.fillStyle = board_color;
		context.strokeStyle = "black";
		drawBorder(x, y, size, size/4);
		context.fill(); context.stroke();
		var thin = size/5;
		context.fillStyle = players_colors[choice];
		context.strokeStyle = players_border_colors[choice];
		context.beginPath();
		if (choice == 0) {
			context.rect(x - size/2 + size/4 - thin, y - size/4, thin, size/2);
		}
		else if (choice == 1) {
			context.rect(x - size/4, y + size/2 - size/4, size/2, thin);			
		}
		else {
			var font_size = size/3;
			context.font = font_size + "px Helvetica";
			context.fillStyle = "antiquewhite";
			context.textBaseline = "middle";
			context.fillText("?", x - context.measureText("?").width/2, y);
		}
		context.fill(); context.stroke();
	}

	function drawBorder(x, y, board_length, tile_length) {
		context.beginPath();
		context.moveTo(x - board_length/2 + tile_length/6 + tile_length/3, y - board_length/2 + tile_length/6);
		context.lineTo(x + board_length/2 - tile_length/6 - tile_length/3, y - board_length/2 + tile_length/6);
		context.arcTo(x + board_length/2 - tile_length/6, y - board_length/2 + tile_length/6, x + board_length/2 - tile_length/6, y - board_length/2 + tile_length/6 + tile_length/3, tile_length/3);
		context.lineTo(x + board_length/2 - tile_length/6, y + board_length/2 - tile_length/6 - tile_length/3);
		context.arcTo(x + board_length/2 - tile_length/6, y + board_length/2 - tile_length/6, x + board_length/2 - tile_length/6 - tile_length/3, y + board_length/2 - tile_length/6, tile_length/3);
		context.lineTo(x - board_length/2 + tile_length/6 + tile_length/3, y + board_length/2 - tile_length/6);
		context.arcTo(x - board_length/2 + tile_length/6, y + board_length/2 - tile_length/6, x - board_length/2 + tile_length/6, y + board_length/2 - tile_length/6 - tile_length/3, tile_length/3);
		context.lineTo(x - board_length/2 + tile_length/6, y - board_length/2 + tile_length/6 + tile_length/3);
		context.arcTo(x - board_length/2 + tile_length/6, y - board_length/2 + tile_length/6, x - board_length/2 + tile_length/6 + tile_length/3, y - board_length/2 + tile_length/6, tile_length/3);
	}

	//Exit button
	drawExitButton(0);
}

function drawBoard() { //Draws normal board
	var w = canvas.width;
	var h = canvas.height;
	var board_length = min - board_margin*sq_length; // RESIZE
	var tile_length = sq_length;
	var size = board_size;
	context.lineWidth = 1;
	drawBackground();
	drawCopyright();
	// Board
	context.fillStyle = board_color; // Board color
	drawBorder();
	context.fill();
	// Crosses
	var furrow_color = "rgb(40,40,40)";
	drawCrosses(furrow_color);
	// Pivots
	drawPivots(furrow_color);
	// Reflection light
	drawReflection("rgb(70,70,70)");
	// Border
	context.strokeStyle = "black";
	drawBorder();
	context.stroke();
	// Paint
	drawPaint("antiquewhite");
	drawPoints("antiquewhite");

	function drawBorder() {
		context.beginPath();
		context.moveTo(w/2 - board_length/2 + tile_length/6 + tile_length/3, h/2 - board_length/2 + tile_length/6);
		context.lineTo(w/2 + board_length/2 - tile_length/6 - tile_length/3, h/2 - board_length/2 + tile_length/6);
		context.arcTo(w/2 + board_length/2 - tile_length/6, h/2 - board_length/2 + tile_length/6, w/2 + board_length/2 - tile_length/6, h/2 - board_length/2 + tile_length/6 + tile_length/3, tile_length/3);
		context.lineTo(w/2 + board_length/2 - tile_length/6, h/2 + board_length/2 - tile_length/6 - tile_length/3);
		context.arcTo(w/2 + board_length/2 - tile_length/6, h/2 + board_length/2 - tile_length/6, w/2 + board_length/2 - tile_length/6 - tile_length/3, h/2 + board_length/2 - tile_length/6, tile_length/3);
		context.lineTo(w/2 - board_length/2 + tile_length/6 + tile_length/3, h/2 + board_length/2 - tile_length/6);
		context.arcTo(w/2 - board_length/2 + tile_length/6, h/2 + board_length/2 - tile_length/6, w/2 - board_length/2 + tile_length/6, h/2 + board_length/2 - tile_length/6 - tile_length/3, tile_length/3);
		context.lineTo(w/2 - board_length/2 + tile_length/6, h/2 - board_length/2 + tile_length/6 + tile_length/3);
		context.arcTo(w/2 - board_length/2 + tile_length/6, h/2 - board_length/2 + tile_length/6, w/2 - board_length/2 + tile_length/6 + tile_length/3, h/2 - board_length/2 + tile_length/6, tile_length/3);
	}

	function drawCrosses(color) {
		for (var i = 0; i < size; i++) {
			for (var j = 0; j < size; j++) {
				drawCross(color, w/2 - board_length/2 + (i+1.5)*tile_length, h/2 - board_length/2 + (j+1.5)*tile_length);
			}
		}
	}

	function drawCross(color, x, y) {
		context.fillStyle = color; // Furrow color
		context.strokeStyle = "black";
		// Arcs
		for (var i = 0; i < 2; i++) {
			var a = i*2 - 1;
			context.beginPath();
			context.arc(x + a*(tile_length/2 - tile_length/6), y, tile_length/6, (1 + i*2)*Math.PI/2, (3 + i*2)*Math.PI/2);
			context.fill(); context.stroke();
			context.beginPath();
			context.arc(x, y + a*(tile_length/2 - tile_length/6), tile_length/6, (2 + i*2)*Math.PI/2, (4 + i*2)*Math.PI/2);
			context.fill(); context.stroke();
		}
		// Rectangles
		context.fillRect(x - tile_length/6, y - tile_length/2 + tile_length/6, tile_length/3, 2*tile_length/3);
		context.fillRect(x - tile_length/2 + tile_length/6, y - tile_length/6, 2*tile_length/3, tile_length/3);
		// Lines
		context.beginPath();
		for (var i = 0; i < 2; i++) {
			var a = i*2 - 1;
			for (var j = 0; j < 2; j++) {
				var b = j*2 - 1;
				context.moveTo(x + a*tile_length/6, y + b*(tile_length/2 - tile_length/6));
				context.lineTo(x + a*tile_length/6, y + b*(tile_length/2 - tile_length/3));
				context.moveTo(x + b*(tile_length/2 - tile_length/6), y + a*tile_length/6);
				context.lineTo(x + b*(tile_length/2 - tile_length/3), y + a*tile_length/6);
			}
		}
		context.fill(); context.stroke();
	}

	function drawPivots(color) {
		for (var i = 0; i < size; i++) {
			drawPivot(color, w/2 - board_length/2 + (i+1.5)*tile_length, h/2 - board_length/2 + 0.5*tile_length, 1, 1);
			drawPivot(color, w/2 - board_length/2 + (i+1.5)*tile_length, h/2 - board_length/2 + (size + 2 - 0.5)*tile_length, 1, -1);
			drawPivot(color, w/2 - board_length/2 + 0.5*tile_length, h/2 - board_length/2 + (i+1.5)*tile_length, -1, 1);
			drawPivot(color, w/2 - board_length/2 + (size + 2 - 0.5)*tile_length, h/2 - board_length/2 + (i+1.5)*tile_length, -1, -1);
		}
	}

	function drawPivot(color, x, y, ori_hv, ori_other) {
		context.fillStyle = color; // Furrow color
		context.strokeStyle = "black";
		// Arcs
		context.beginPath();
		context.arc(x + (ori_other)*(ori_hv == 1 ? 0 : 1)*(tile_length/2 - tile_length/6), y + (ori_other)*(ori_hv == 1 ? 1 : 0)*(tile_length/2 - tile_length/6), tile_length/6, (ori_hv == 1 ? 0 + (ori_other == 1 ? 0 : 2) : 3 + (ori_other == 1 ? 0 : 2))*Math.PI/2, (ori_hv == 1 ? 2 + (ori_other == 1 ? 0 : 2) : 5 + (ori_other == 1 ? 0 : 2))*Math.PI/2);
		context.fill(); context.stroke();
		// Rectangles
		context.fillRect(x - (ori_hv == 1 ? tile_length/6 : tile_length/2 - tile_length/6), y - (ori_hv == 1 ? tile_length/2 - tile_length/6 : tile_length/6), (ori_hv == 1 ? 1 : 2)*tile_length/3, (ori_hv == 1 ? 2 : 1)*tile_length/3);
		// Lines
		context.beginPath();
		for (var i = 0; i < 2; i++) {
			var a = i*2 - 1;
			context.moveTo(x + (ori_hv == 1 ? a*tile_length/6 : - tile_length/2 + tile_length/6), y + (ori_hv == 1 ? - tile_length/2 + tile_length/6 : a*tile_length/6));
			context.lineTo(x + (ori_hv == 1 ? a*tile_length/6 : + tile_length/2 - tile_length/6), y + (ori_hv == 1 ? + tile_length/2 - tile_length/6 : a*tile_length/6));
		}
		context.stroke();
	}

	function drawReflection(color) {
		context.strokeStyle = color; // Reflection color
		context.beginPath();
		for (var i = 0; i < size; i++) {
			context.moveTo(w/2 - board_length/2 + (i+1.5)*tile_length, h/2 - board_length/2 + tile_length/6);
			context.lineTo(w/2 - board_length/2 + (i+1.5)*tile_length, h/2 + board_length/2 - tile_length/6);
			context.moveTo(w/2 - board_length/2 + tile_length/6, h/2 - board_length/2 + (i+1.5)*tile_length);
			context.lineTo(w/2 + board_length/2 - tile_length/6, h/2 - board_length/2 + (i+1.5)*tile_length);
		}
		context.stroke();
	}

	function drawPaint(color) {
		// Line
		context.strokeStyle = color;
		context.lineWidth = Math.max(2, tile_length/30);
		context.beginPath();
		context.arc(w/2 - board_length/2 + 1.5*tile_length - tile_length/6, h/2 + board_length/2 - 1.5*tile_length + tile_length/6, tile_length/2 - tile_length/6, Math.PI/2, Math.PI);
		context.stroke();
		context.beginPath();
		for (var i = 0; i < size - 1; i++) {
			context.moveTo(w/2 - board_length/2 + tile_length, h/2 - board_length/2 + (i+1.5)*tile_length + tile_length/6);
			context.lineTo(w/2 - board_length/2 + tile_length, h/2 - board_length/2 + (i+1.5)*tile_length + tile_length/6 + 2*tile_length/3);
			context.moveTo(w/2 - board_length/2 + (i+1.5)*tile_length + tile_length/6, h/2 + board_length/2 - tile_length);
			context.lineTo(w/2 - board_length/2 + (i+1.5)*tile_length + tile_length/6 + 2*tile_length/3, h/2 + board_length/2 - tile_length);
		}
		context.stroke();
		context.lineWidth = 1;
	}

	function drawPoints(color) {
		var speeds = (size == 5 ? SPEEDS["5"] : SPEEDS["3"]);
		context.fillStyle = color;
		for (var i = 0; i < size; i++) {
			for (var j = 0; j < speeds["left"][i]; j++) {
				context.beginPath();
				context.arc(w/2 - board_length/2 + tile_length/3 + j*tile_length/6, h/2 - board_length/2 + (i+1.5)*tile_length - tile_length/3.5, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.arc(w/2 - board_length/2 + tile_length/3 + j*tile_length/6, h/2 - board_length/2 + (i+1.5)*tile_length + tile_length/3.5, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.fill();
				context.beginPath();
				context.arc(w/2 - board_length/2 + (i+1.5)*tile_length - tile_length/3.5, h/2 - board_length/2 + tile_length/3 + j*tile_length/6, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.arc(w/2 - board_length/2 + (i+1.5)*tile_length + tile_length/3.5, h/2 - board_length/2 + tile_length/3 + j*tile_length/6, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.fill();
			}
			for (var j = 0; j < speeds["bottom"][i]; j++) {
				context.beginPath();
				context.arc(w/2 + board_length/2 - tile_length/3 - j*tile_length/6, h/2 + board_length/2 - (i+1.5)*tile_length + tile_length/3.5, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.arc(w/2 + board_length/2 - tile_length/3 - j*tile_length/6, h/2 + board_length/2 - (i+1.5)*tile_length - tile_length/3.5, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.fill();
				context.beginPath();
				context.arc(w/2 + board_length/2 - (i+1.5)*tile_length + tile_length/3.5, h/2 + board_length/2 - tile_length/3 - j*tile_length/6, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.arc(w/2 + board_length/2 - (i+1.5)*tile_length - tile_length/3.5, h/2 + board_length/2 - tile_length/3 - j*tile_length/6, Math.max(2, tile_length/30), 0, 2*Math.PI);
				context.fill();
			}
		}
	}

	//Turn ball (including advantage)
	//calculateMovesToFinish(); //Updates best_player
	////drawColorCircle(margin_x + sq_length*1.5 + sq_length/6, margin_y + (board_size + 2.5)*sq_length - sq_length/6, sq_length/3, 1, (best_player == turn ? adv_green : adv_red));
	var text = (turn == 0 ? "\uf337" : "\uf338");
	drawButton(margin_x + sq_length*0.5 + sq_length/6, margin_y + (board_size + 1.5)*sq_length - sq_length/6, sq_length/3, players_colors[turn], "black", 1, text, players_backbone_colors[turn], players_border_colors[turn]);

	//Code button
	var text = "\uf121"; //Code
	drawButton(margin_x + (board_size + 1.5)*sq_length - sq_length/6, margin_y + (board_size + 1.5)*sq_length - sq_length/6, sq_length/3, "antiquewhite", "black", 1, text, board_color, "black");

	if (show_advantage) {
		context.fillStyle = "black";
		var font_size = sq_length*2/5;
		context.font = font_size + "px Helvetica";
		var text = calculateMovesToFinish()[turn];
		context.fillText(text, margin_x + sq_length*1.5 - context.measureText(text).width/2, margin_y + (board_size + 2.5)*sq_length);
	}

	//Pieces and exit button
	if (replay == null) { //Usual
		drawPieces();
		drawExitButton(1);
	}
	else { //Replay
		drawExitButton(1);
	}
}

function drawReplayBoard() { //Draws replay board
	//drawBackgroundLimited(margin_x + sq_length + margin, margin_y + sq_length + margin, sq_length - 2*margin, sq_length - 2*margin);
	drawBackground();
	drawBoard(); //Board without background and pieces
	drawAdvanceButtons();

	//Overall fraction
	context.fillStyle = "antiquewhite";
	font_size = Math.sqrt(board_size - 1)*sq_length*3/5;
	context.font = font_size + "px Helvetica";
	context.textBaseline = "middle";
	var len_rep = Math.floor(Math.log(replay.length - 2)/Math.log(10));
	var len_step = Math.floor(Math.log((replay_step == 0 ? 1 : replay_step))/Math.log(10));
	var extra = ""; //This beautifies by adding 0's at the begining
	for (var i = 0; i < len_rep - len_step; i++) {
		extra += "0";
	}
	var text = extra + replay_step + "/" + (replay.length - 2);
	context.globalAlpha = 0.25;
	context.fillText(text, canvas.width/2 - context.measureText(text).width/2, canvas.height/2);
	context.globalAlpha = 1;

	//Statistics button
	var radius = sq_length/3;
	var x = margin_x + 2*sq_length - radius;
	var y = margin_y + 2*sq_length - radius;
	var winner = replay[replay.length - 1];
	var text = "\uf1fe"; //Chart
	drawButton(x - sq_length*1, y - sq_length*1, radius, "antiquewhite", "black", 1, text, players_colors[winner], players_border_colors[winner]); // RESIZE

	//Code button
	// var radius = sq_length/3;
	// var x = canvas.width - (margin_x + 2*sq_length - radius);
	// var y = canvas.height - (margin_y + 2*sq_length - radius);
	// var text = "\uf121"; //Code
	// drawButton(x, y, radius, "antiquewhite", "black", 1, text, board_color, "black");

	//Write pieces
	drawPieces();
}

function drawStatistics(x, y, w, h) { //Draws statistics chart
	drawBackground();
	drawAdvanceButtons();
	//Axis
	drawAxis(x, y, w, h);
	//Fixed values
	context.fillStyle = "black";
	loadBoard(0);
	var max = Math.max(calculateMovesToFinish()[0], calculateMovesToFinish()[1]);
	font_size = min/20;
	context.font = font_size + "px Helvetica";
	context.textBaseline = "middle";
	var text = max;
	context.fillText(text, x - sq_length/4 - context.measureText(text).width/2, y);
	text = 0;
	context.fillText(text, x - sq_length/4 - context.measureText(text).width/2, y + h + sq_length/4);
	text = replay.length - 2;
	context.fillText(text, x + w - context.measureText(text).width/2, y + h + sq_length/4);
	//Graph
	var greatest_difference = 0; //Saves the greatest difference
	var greatest_difference_point = new Array(); //Saves where it happened
	var greatest_difference_height = [new Array(), new Array()]; //Saves the vertical extremes
	var winner = replay[replay.length - 1];
	drawGraph((winner + 1)%2);
	drawGraph(winner);

	//Best moves
	//drawBestMoves();
	//Greatest difference
	drawGreatestDifference();

	//Horizontal cuts
	var min_y = canvas.width;
	context.strokeStyle = "black";
	context.lineWidth = 1;
	var val = calculateMovesToFinish();
	for (var i = 0; i < val.length && val[i] != 0; i++) {
		context.beginPath();
		context.moveTo(x, y + h - val[i]*h/max);
		context.lineTo(x + replay_step*w/(replay.length - 2), y + h - val[i]*h/max);
		context.strokeStyle = "black";
		context.globalAlpha = 0.25;
		context.stroke();
		//Colors text
		context.globalAlpha = 0.5;
		context.fillStyle = players_colors[i];
		context.fillText(val[i], x - sq_length/4 - context.measureText(val[i]).width/2, y + h - val[i]*h/max);
		context.strokeText(val[i], x - sq_length/4 - context.measureText(val[i]).width/2, y + h - val[i]*h/max);
		min_y = Math.min(min_y, y + h - val[i]*h/max);
	}
	//Current step bar
	context.strokeStyle = "black";
	context.beginPath();
	context.moveTo(x + replay_step*w/(replay.length - 2), min_y);
	context.lineTo(x + replay_step*w/(replay.length - 2), y + h);
	context.globalAlpha = 0.25;
	context.stroke();
	//Step text
	context.globalAlpha = 0.5;
	context.fillStyle = "black";
	context.fillText(replay_step, x + replay_step*w/(replay.length - 2) - context.measureText(replay_step).width/2, y + h + sq_length/4);
	context.globalAlpha = 1;

	//Board button
	var radius = min/20;
	var x = canvas.width/2;
	var y = canvas.height/10;
	var text = "\uf009"; //Square
	drawButton(x, y, radius, "antiquewhite", "black", 1, text, board_color, "black");
	//Header
	var text = "Moves to finish";
	font_size = min/15;
	var y = canvas.height/4;
	context.font = font_size + "px Helvetica";
	context.textBaseline = "middle";
	context.fillStyle = background_color;
	context.fillRect(canvas.width/2 - context.measureText(text).width/2, y - font_size*2/3, context.measureText(text).width, font_size*4/3);
	context.fillStyle = "antiquewhite";
	context.strokeText(text, canvas.width/2 - context.measureText(text).width/2, y);
	context.fillText(text, canvas.width/2 - context.measureText(text).width/2, y);

	function drawAxis(x, y, w, h) {
		context.strokeStyle = "black";
		context.lineWidth = 3;
		context.beginPath();
		context.moveTo(x + w, y + h);
		context.lineTo(x + min/20, y + h);
		context.arc(x + min/20, y + h - min/20, min/20, Math.PI/2, Math.PI);
		context.lineTo(x, y);
		context.stroke();
	}
	
	function drawGraph(pl) { //Draws graph for player pl
		loadBoard(0);
		var moves = calculateMovesToFinish()[pl];
		var moves_rival = calculateMovesToFinish()[(pl + 1)%2];
		var aux = calculateMovesToFinish()[pl]; //This will save the moves in the previous hand
		context.beginPath();
		context.moveTo(x, y + h - moves*h/max);
		for (var i = 1; i < replay.length - 1; i++) {
			loadBoard(i);
			moves = calculateMovesToFinish()[pl];
			moves_rival = calculateMovesToFinish()[(pl + 1)%2];
			context.lineTo(x + i*w/(replay.length - 2), y + h - moves*h/max);
			//Save greatest difference
			if (greatest_difference < Math.abs(moves - moves_rival)) {
				greatest_difference = Math.abs(moves - moves_rival);
				greatest_difference_point = new Array();
				greatest_difference_point.push(i);
				greatest_difference_height = [new Array(), new Array()];
				greatest_difference_height[pl].push(y + h - moves*h/max);
			}
			else if (greatest_difference == Math.abs(moves - moves_rival)) {
				greatest_difference_point.push(i);
				greatest_difference_height[pl].push(y + h - moves*h/max);
			}
			aux = moves;
		}
		context.strokeStyle = players_border_colors[pl];
		context.lineCap = "round";
		context.lineWidth = 3;
		context.stroke();
		context.lineTo(x + w, y + h);
		context.lineTo(x + min/20, y + h);
		context.arc(x + min/20, y + h - min/20, min/20, Math.PI/2, Math.PI);
		context.closePath();
		context.fillStyle = players_colors[pl];
		context.globalAlpha = 0.25;
		context.fill();
		context.globalAlpha = 1;
		context.lineCap = "butt";
		loadBoard(replay_step);
	}

	function drawGreatestDifference() { //Draws the greatest difference interval, with number in the middle
		context.globalAlpha = 0.25;
		context.lineWidth = 1;
		for (var i = 0; i < 2; i++) {
			for (var j = 0; j < greatest_difference_point.length; j++) {
				context.beginPath();
				context.strokeStyle = "black";
				if (replay_step == greatest_difference_point[j]) { //If replay on position write number and lines
					if (greatest_difference_height[i][j] < greatest_difference_height[(i + 1)%2][j]) { //Draw bars with gradient
						//Gradient
						var gradient = context.createLinearGradient(x - sq_length/4, greatest_difference_height[i][j] + font_size/2, x - sq_length/4, greatest_difference_height[(i + 1)%2][j] - font_size/2);
						gradient.addColorStop(0, players_colors[i]);
						gradient.addColorStop(1, players_colors[(i + 1)%2]);
						context.strokeStyle = gradient;
					}
				}
				context.moveTo(x + greatest_difference_point[j]*w/(replay.length - 2), greatest_difference_height[i][j]);
				context.lineTo(x + greatest_difference_point[j]*w/(replay.length - 2), greatest_difference_height[(i + 1)%2][j]);
				context.stroke();
			}
		}
		context.globalAlpha = 1;
	}
}

function createPieces() { //Creates all pieces and current_state
	for (var i = 0; i < player.length; i++) {
		player[i] = new Array(board_size);
		current_state[i] = new Array(board_size);
		for (var j = 0; j < player[i].length; j++) {
			var value;
			if (board_size%2 == 0) { //Size even [1 5 2 4 3 3 4 2 5 1]
				value = (j%2 == 0 ? (Math.floor(j/2) + 1) : (board_size/2 - Math.floor(j/2)));
			}
			else { //Size odd [1 5 2 4 3 4 2 5 1]
				if (j%2 == 0) {
					value = (j < board_size/2 ? (Math.floor(j/2) + 1) : (Math.floor((board_size - j)/2) + 1));
				}
				else {
					value = (j < board_size/2 ? Math.floor((board_size + 2 - j)/2) : (Math.floor(j/2) + 2));
				}
			}
			player[i][j] = new Piece(i, (i == 0 ? 0 : j + 1), (i == 0 ? j + 1 : board_size + 1), (i == 0 ? value : Math.floor(board_size/2) - value + (board_size%2 == 0 ? 1 : 2)));
		}
	}
}

function drawPieces() { //Draws all pieces
	for (var i = 0; i < player.length; i++) {
		for (var j = 0; j < player[i].length; j++) {
			player[i][j].draw();
		}
	}
}

function drawSettings() { //Draws choose colors, show advantage
	drawBackground();
	var margin = 6;
	var radius = min/16;
	var color_radius = Math.min(radius, min/(3*colors_display.length));
	//Colors (row with colors, and current choice)
	for (var i = 1; i <= colors_display.length; i++) {
		if (i - 1 == chosen_color) {
			drawColorCircle(i*canvas.width/(colors_display.length + 1), canvas.height/5, color_radius + margin, 3, aura_color);
		}
		drawColorCircle(i*canvas.width/(colors_display.length + 1), canvas.height/5, color_radius, 3, colors_display[i - 1]);
	}
	//Current choice
	drawColorCircle((color_player == 0 ? 1 : 2)*canvas.width/3, canvas.height*2/5, radius + margin, 3, aura_color);
	for (var i = 1; i <= players_colors.length; i++) {
		drawStandardPiece(i*canvas.width/3, canvas.height*2/5, radius, 1, players_colors[i - 1]);
	}
	//Division line
	context.strokeStyle = "black";
	context.lineWidth = 3;
	context.beginPath();
	var dashes = 23; //Keep it odd
	for (var i = 0; i < dashes; i += 2) {
		context.moveTo(i*canvas.width/dashes, canvas.height*2.5/5);
		context.lineTo((i + 1)*canvas.width/dashes, canvas.height*2.5/5);
	}
	context.stroke();
	//Show advantage
	context.strokeStyle = "black";
	context.lineWidth = 3;
	context.fillStyle = aura_color;
	context.fillRect((show_advantage ? 2 : 1)*canvas.width/3 - radius - margin, canvas.height*3/5 - radius/2 - margin, 2*radius + 2*margin, radius + 2*margin);
	context.strokeRect((show_advantage ? 2 : 1)*canvas.width/3 - radius - margin, canvas.height*3/5 - radius/2 - margin, 2*radius + 2*margin, radius + 2*margin);
	context.fillStyle = "black";
	context.fillRect(canvas.width/3 - radius, canvas.height*3/5 - radius/2, 2*radius, radius);
	context.strokeRect(canvas.width/3 - radius, canvas.height*3/5 - radius/2, 2*radius, radius);
	context.fillStyle = adv_red;
	context.fillRect(canvas.width*2/3 - radius, canvas.height*3/5 - radius/2, radius, radius);
	context.strokeRect(canvas.width*2/3 - radius, canvas.height*3/5 - radius/2, radius, radius);
	context.fillStyle = adv_green;
	context.fillRect(canvas.width*2/3, canvas.height*3/5 - radius/2, radius, radius);
	context.strokeRect(canvas.width*2/3, canvas.height*3/5 - radius/2, radius, radius);
	//Turn decision (first player, second player, random)
	for (var i = 1; i <= 3; i++) {
		if (i - 1 == chosen_turn) { //Orange border
			drawColorCircle(i*canvas.width/4, canvas.height*4/5, radius*2/3 + margin, 3, aura_color);
		}
		if (i < 3) { //Advantage color
			if (chosen_turn < 2) {
				drawColorCircle(i*canvas.width/4, canvas.height*4/5, radius*2/3, 3, (chosen_turn == i - 1 ? adv_green : adv_red));
			}
			else {
				drawColorHalfCircle(i*canvas.width/4, canvas.height*4/5, radius*2/3, 3, (i == 1 ? adv_green : adv_red), (i == 1 ? adv_red : adv_green));	
			}
		}
		if (i < 3) { //Advantage inner circle
			drawColorCircle(i*canvas.width/4, canvas.height*4/5, (show_advantage ? 2/3 : 1)*(radius*2/3), (show_advantage ? 1 : 3), players_colors[i - 1]);
		}
		else {
			drawColorHalfCircle(i*canvas.width/4, canvas.height*4/5, radius*2/3, 3, players_colors[0], players_colors[1]);
		}
	}
	//Exit button
	drawExitButton(0);
}

function drawHelp() { //Draws help
	drawBackground();

	//Settings buttons

	//Gameplay (rules and buttons)

	//Replay

	//Exit button
	drawExitButton(0);
}

function drawNotice() { //Draws notice
	drawBackground();
	var colors = ["red", "yellow", "blue"];
	var radius = min/18;
	/*for (var i = 0; i < colors.length; i++) {
		drawStandardPiece(canvas.width/4 - radius*Math.sin(2*Math.PI*i/colors.length), canvas.height/4 - radius*Math.cos(2*Math.PI*i/colors.length) + radius/6, radius*2/3, 1, colors[i]);
		drawStandardPiece(canvas.width*3/4 - radius*Math.sin(2*Math.PI*i/colors.length), canvas.height/4 - radius*Math.cos(2*Math.PI*i/colors.length) + radius/6, radius*2/3, -1, colors[i]);
	}*/
	for (var i = 0; i < colors.length; i++) {
		drawStandardPiece(canvas.width/2 + 4*radius*(i - 1), canvas.height*2/8, radius, -1, colors[i]);
		drawStandardPiece(canvas.width/2 + 4*radius*(i - 1), canvas.height*6/8, radius, 1, colors[i]);
	}
	context.fillStyle = "black";
	var font_size = min/24;
	context.font = font_size + "px Helvetica";
	var text = ["SQUADRO was originally devised by",
		"Adri\u00E1n Jim\u00E9nez Pascual (\u00A9Adr\u00ef)",
		"in March 2015 as a physical board game.",
		"This digital version was fully developed",
		"by himself and concluded in August 2015.",
		];
	for (var i = 0; i < text.length; i++) {
		context.fillText(text[i], canvas.width/2 - context.measureText(text[i]).width/2, canvas.height*(6 + i)/16);
	}

	//Exit button
	drawExitButton(0);
}

function drawWords() { //Draws the spoken words
	// HAGA LO QUE HAGA, LOS VALORES DE SPEAK DEBEN RESTABLECERSE A FALSE TRAS EL DIBUJO

	context.fillStyle = "black";
	var font_size = exit_font_size*2;
	context.font = font_size + "px Helvetica";
	var text = "SPAR";
	if (speak[0]) {
		context.fillText(text, canvas.width - margin_x - 2*sq_length + exit_margin, margin_y + sq_length + exit_margin + font_size/4, 2*sq_length - 2*exit_margin);
		setTimeout(function() {
			context.fillStyle = background_color;
			context.fillRect(canvas.width - margin_x - 2*sq_length + exit_margin/2, margin_y + exit_margin/2, 2*sq_length - exit_margin, 2*sq_length - exit_margin);
			if (speak[1] || (speak[2] && !speak[3])) {
				setTimeout(function() {
					text = (speak[1] ? "FRATAMA" : "BITYA");
					context.fillText(text, canvas.width - margin_x - 2*sq_length + exit_margin, margin_y + sq_length + exit_margin + font_size/4, 2*sq_length - 2*exit_margin);

				}, text_time + text_time/4);
				
			}
		}, text_time);
	}
}

//Absolute functions
function drawBackground() { //Draws background (including copyright)
	context.fillStyle = background_color;
	context.fillRect(0, 0, canvas.width, canvas.height);
	//drawCopyright();
}

function drawBackgroundLimited(x, y, w, h) { //Covers all but the space for graph button in replay
	context.fillStyle = background_color;
	context.fillRect(0, 0, canvas.width, y);
	context.fillRect(0, 0, x, canvas.height - sq_length);
	context.fillRect(x + w, 0, canvas.width - x - w, canvas.height);
	context.fillRect(0, y + h, canvas.width, canvas.height - y - h);
	//drawCopyright();
}

function drawCopyright() { //Draws name and copyright
	var font_size = sq_length/2;
	context.font = "italic " + font_size + "px Helvetica";
	context.fillStyle = copyright_color;
	context.textBaseline = "middle";
	var text = "Squadro" /*+"\u2212"*/;
	context.fillText(text, canvas.width/2 - context.measureText(text).width/2, sq_length/2);
	font_size = sq_length/6;
	context.font = font_size + "px Helvetica";
	context.textBaseline = "bottom";
	text = "\u00AE & \u00A9 2018 GIGAMIC from a concept of Adri\u00E1n Jim\u00E9nez Pascual";
	context.fillText(text, canvas.width/2 - context.measureText(text).width/2, canvas.height - sq_length/2);
}

function drawColorCircle(x, y, radius, lineWidth, color) { //Draws circle with settings
	context.fillStyle = color;
	context.strokeStyle = "black";
	context.lineWidth = lineWidth;
	context.beginPath();
	context.arc(x, y, radius, 0, 2*Math.PI);
	context.fill();
	context.stroke();
}

function drawColorHalfCircle(x, y, radius, lineWidth, color1, color2) { //Draw circle with two halves with settings
	context.fillStyle = color1;
	context.beginPath();
	context.arc(x, y, radius, Math.PI/2, Math.PI*3/2);
	context.fill();
	context.fillStyle = color2;
	context.beginPath();
	context.arc(x, y, radius, Math.PI*3/2, Math.PI*5/2);
	context.fill();
	context.strokeStyle = "black";
	context.lineWidth = lineWidth;
	context.beginPath();
	context.arc(x, y, radius, 0, 2*Math.PI);
	context.stroke();
}

function drawExitButton(position) { //Draws exit button. Position = 0 (centered), 1 (right-square of the board) or 2 (left-square of the board)
	context.fillStyle = "white";
	context.strokeStyle = "black";
	context.lineWidth = 3;
	var margin = exit_margin;
	var side = min/10;
	var sq_width = sq_length*2/3;
	var radius = (position == 0 ? side : sq_width)/2;
	var x = (position == 0 ? canvas.width/2 : (position == 1 ? canvas.width - margin_x - 2*sq_length : margin_x + sq_length) + radius);
	var y = (position == 0 ? canvas.height/10 : margin_y + 2*sq_length - radius);
	var text = "\uf1de"; //Sliders (adjust)
	drawButton(x + sq_length*1, y - sq_length*1, radius, "antiquewhite", "black", (position == 0 ? 3 : 1), text, board_color, null); // RESIZE
}

function drawButton(x, y, radius, fill_color, stroke_color, width, text, text_fill, text_stroke) {
	context.fillStyle = fill_color;
	context.strokeStyle = stroke_color;
	context.lineWidth = width;
	context.beginPath();
	context.arc(x, y, radius, 0, 2*Math.PI);
	context.fill();
	context.stroke();
	//Content
	context.fillStyle = text_fill;
	context.strokeStyle = text_stroke;
	context.font = "900 " + radius + 'px "Font Awesome 5 Free"';
	context.lineWidth = 1;
	context.textBaseline = "middle";
	context.fillText(text, x - context.measureText(text).width/2, y);
	context.strokeText(text, x - context.measureText(text).width/2, y);
}

function drawReplayButton(x, y, radius) { //Draws replay button
	drawColorCircle(x, y, radius, 3, "white");
	context.strokeStyle = "black";
	context.lineWidth = ((navigator.userAgent.match(/iPhone/i) != null) || (navigator.userAgent.match(/iPad/i) != null) ? 3 : 5);
	context.beginPath();
	context.arc(x, y, radius/2, Math.PI*3/2, Math.PI*3);
	context.stroke();
	context.fillStyle = "black";
	context.beginPath();
	context.moveTo(x - radius/2 - radius/2/3, y + radius/2/6);
	context.lineTo(x - radius/2 + radius/2/3, y + radius/2/6);
	context.lineTo(x - radius/2, y - radius/2/3);
	context.closePath();
	context.fill();
}

function drawSettingsButton(x, y, radius) { //Draws settings button
	drawColorCircle(x, y, radius, 3, "white");
	var line_width = 2;
	drawColorCircle(x, y - radius*3/5, radius/4, line_width, colors_display[3]);
	drawColorCircle(x, y + radius*3/5, radius/4, line_width, colors_display[4]);
	drawColorCircle(x - radius*3/5, y, radius/4, line_width, colors_display[0]);
	drawColorCircle(x, y, radius/4, line_width, colors_display[1]);
	drawColorCircle(x + radius*3/5, y, radius/4, line_width, colors_display[2]);
}

function drawHelpButton(x, y, radius) { //Draws help button
	drawColorCircle(x, y, radius, 3, "white");
	context.fillStyle = "black";
	var font_size = radius*3/2;
	context.font = font_size + "px Helvetica";
	var text = "?";
	context.fillText(text, x - context.measureText(text).width/2, y);
}

function drawNoticeButton(x, y, radius) { //Draws notice button
	drawColorCircle(x, y, radius, 3, "white");
	context.fillStyle = "black";
	var font_size = radius*3/2;
	context.font = font_size + "px Helvetica";
	var text = "!";
	context.fillText(text, x - context.measureText(text).width/2, y);
}

function drawStandardPiece(x, y, radius, direction, color) { //Draws the standar piece with the variables
	context.fillStyle = "rgb(110,50,10)";
	context.strokeStyle = "black";
	context.lineWidth = 1;
	context.beginPath();
	context.arc(x, y, radius, 0, 2*Math.PI);
	context.fill();
	context.stroke();
	//Add orientation
	context.fillStyle = color;
	context.strokeStyle = "black";
	context.beginPath();
	context.arc(x, y, radius*2/3, 0, Math.PI);
	context.closePath();
	context.fill();
	context.stroke();
	//Triangle
	context.fillStyle = "white";
	context.strokeStyle = "black";
	context.beginPath();
	if (direction == 1) {
		context.moveTo(x - radius/3, y);
		context.lineTo(x, y - radius*2/3);
		context.lineTo(x + radius/3, y);
	}
	else {
		context.moveTo(x - radius/3, y - radius*2/3);
		context.lineTo(x, y);
		context.lineTo(x + radius/3, y - radius*2/3);
	}
	context.closePath();
	context.fill();
	context.stroke();
}

function drawAdvanceButtons() { //Draws advance/go back buttons
	var radius = min/20;
	var text = "\uf049"; //Rewind
	drawButton(canvas.width/8, canvas.height/2 - radius, radius, "rgb(200,170,170)", "black", 1, text, board_color, "black");
	text = "\uf048"; //Back
	drawButton(canvas.width/8, canvas.height/2 + radius, radius, "rgb(255,230,230)", "black", 1, text, board_color, "black");
	text = "\uf050"; //Fast forward
	drawButton(canvas.width*7/8, canvas.height/2 - radius, radius, "rgb(170,200,170)", "black", 1, text, board_color, "black");
	text = "\uf051"; //Forward
	drawButton(canvas.width*7/8, canvas.height/2 + radius, radius, "rgb(230,255,230)", "black", 1, text, board_color, "black");
}

/**** BOTS ****/

var Bot = function(level) {
	this.level = level;
	this.chosen_piece; //Piece to be moved
}

Bot.prototype.simulate = function() { //Updates this.chosen_piece
	var chosen_piece;
	var movable_pieces = this.ordered_movables(turn);
	var rival_movable_pieces = this.ordered_movables((turn + 1)%2);
	var blocked_pieces = new Array(); //Will save any piece that should not be moved
	switch (this.level) {
		case 0: //Basic bot
			// Check piece by piece if "i" can move safely or "movable_pieces.length - 1 - i" can eat
			for (var i = 0; i < movable_pieces.length && chosen_piece == null; i++) {
				if (movable_pieces[i].directThreaten(1) == null) { //If can move
					chosen_piece = movable_pieces[i];
				}
				else if (movable_pieces[movable_pieces.length - 1 - i].calculateNextAdvance().length > 0) { //If can eat
					chosen_piece = movable_pieces[movable_pieces.length - 1 - i];
				}
			}
			if (chosen_piece == null) {
				chosen_piece = movable_pieces[movable_pieces.length - 1];	
			}
			break;
		case 2: //Bot with memory
			// 1. Takes pieces in order, and checks if their neighbourhoods existed previously in all boards of board_records
			// 1.a. If existed, take the percentage of victories
			// 1.b. If doesn't exist, choose it (if it's not good it will naturally be unselected consecuently)
			// 2. If all existed, choose best percentage

			//Initialize victory_percentages (to 1)
			var victory_percentages = new Array(movable_pieces.length);
			for (var i = 0; i < victory_percentages.length; i++) {
				victory_percentages[i] = 1;
			}
			//Take neighbourhoods and apply method
			for (var i = 0; i < movable_pieces.length; i++) { //Through all neighbourhoods
				var neigh = movable_pieces[i].neighbourhood();
				var coincidences = 1; //Number of appearances (starts in 1 because of the initialization)
				for (var j = 0; j < board_records.length; j++) { //Through all boards
					for (var k = 0; k < board_records[j].length - 1; k++) { //(Takes out last value, which is the winner)
						if (contained(neigh, board_records[j][k])) { //If the neighbourhood is in
							coincidences++;
							var result = (turn == board_records[j][board_records[j].length - 1] ? 1 : 0); //Assing victory or loss
							victory_percentages[i] = (victory_percentages[i]*(coincidences - 1) + result)/coincidences;
						}
					}
				}
			}
			//Take best percentage
			movable_pieces.sort(function(a, b) {
				return victory_percentages[movable_pieces.indexOf(b)] - victory_percentages[movable_pieces.indexOf(a)];
			});
			//Take the piece
			chosen_piece = movable_pieces[0];
			break;
		case 1: //Bot with strategy
			// 0. Order pieces (done)
			// 1. Try to eat rival's "important" pieces
			// 1,5. If not eatable try to threaten them
			// 2. Else, move own threatened to safe
			// 3. Try to attack safely OR attack rival's weak
			// 4. Move to safe
			// 4,5. Eat any, whether threatened in next move or not
			// 5. Move last non-blocked sorted
			// 6. If all blocked, move last blocked

			//Determine "important" pieces' value
			var weakest_value = board_size;
			for (var i = 0; i < rival_movable_pieces.length; i++) {
				weakest_value = Math.min(weakest_value, rival_movable_pieces[i].value);
			}
			// 1. Try to eat "importants"
			for (var i = 0; i < rival_movable_pieces.length && rival_movable_pieces[i].value == weakest_value && chosen_piece == null; i++) {
				var threaten = rival_movable_pieces[i].directThreaten(0);
				if (threaten != null) { //If eatable
					chosen_piece = threaten;
				}
			}
			// 1,5. Prepare to threaten "importants". Preferably threat with closest ones (if by staying stand is not enough)
			for (var i = 0; i < rival_movable_pieces.length && rival_movable_pieces[i].value == weakest_value && chosen_piece == null; i++) {
				var coord_rival = (turn == 0 ? rival_movable_pieces[i].x : rival_movable_pieces[i].y);
				var coord_rival_alt = (turn == 0 ? rival_movable_pieces[i].y : rival_movable_pieces[i].x);
				var candidates = new Array(); 
				var total_candidates = new Array();
				for (var j = movable_pieces.length - 1; j >= 0 && chosen_piece == null; j--) {
					var coord_own = (turn == 0 ? movable_pieces[j].y : movable_pieces[j].x);
					var distance_to_rival = movable_pieces[j].reachesIn(coord_rival);
					var distance_to_own = rival_movable_pieces[i].reachesIn(coord_own);
					var distance_to_lane = (turn == 0 ? coord_rival_alt : board_size - coord_rival_alt);
					if (1 <= distance_to_rival && distance_to_own <= distance_to_lane && distance_to_rival <= distance_to_own + 1) { //If own is ahead and can eat, and it takes less or equal moves to catch, keep it
						total_candidates.push(movable_pieces[j]);
						if (distance_to_rival == distance_to_own + 1) {
							candidates.push(movable_pieces[j]);
						}
					}
				}
				total_candidates.sort(function(a, b) { //Sorts from closest to rival's to furthest
					if (turn == 0) {
						return Math.abs(a.y - rival_movable_pieces[i].y) - Math.abs(b.y - rival_movable_pieces[i].y);
					}
					else {
						return Math.abs(a.x - rival_movable_pieces[i].x) - Math.abs(b.x - rival_movable_pieces[i].x);
					}
				});
				if (total_candidates.length > 0) { //If there are candidates, block the closest
					if (candidates.indexOf(total_candidates[0]) > -1) { //If closest candidate is at limit distance, take it closer
						chosen_piece = total_candidates[0];
					}
					else { //Else, block closest
						if (blocked_pieces.indexOf(total_candidates[0]) == -1) { //If first time that piece is blocked
							blocked_pieces.push(total_candidates[0]);
						}
					}
				}
			}
			// 2. If not "important" is eaten or threatened, choose threatened to safe
			var all_threatened = true;
			for (var i = 0; i < movable_pieces.length && chosen_piece == null; i++) {
				if (movable_pieces[i].directThreaten(0) != null) {
					if (movable_pieces[i].directThreaten(1) == null) {
						chosen_piece = movable_pieces[i];
					}
				}
				else {
					all_threatened = false;
				}
			}
			// 3. Try to attack any with own next move safe OR attack rival's weak
			var eating_candidate;
			for (var i = 0; i < rival_movable_pieces.length && chosen_piece == null; i++) {
				var threaten = rival_movable_pieces[i].directThreaten(0);
				var threaten_own_next = (threaten != null ? threaten.directThreaten(1) : null);
				if (threaten != null) { //If eatable
					if (threaten_own_next == null || rival_movable_pieces[i].value == weakest_value) { //If next move is safe, or rival weak
						chosen_piece = threaten;
					}
					else if (eating_candidate == null) { //If not weak and unsafe, keep reference
						eating_candidate = threaten;
					}
				}
			}
			// 4. Move safely
			for (var i = 0; i < movable_pieces.length && chosen_piece == null; i++) {
				if (movable_pieces[i].directThreaten(1) == null) {
					chosen_piece = movable_pieces[i];
				}
			}
			// 4,5. If cannot move safely, eat the kept candidate
			if (chosen_piece == null && eating_candidate != null) {
				chosen_piece = eating_candidate;
			}
			// 5. In any other case, take last non-blocked piece in decreasing order
			for (var i = movable_pieces.length - 1; i >= 0 && chosen_piece == null; i--) {
				if (blocked_pieces.indexOf(movable_pieces[i]) == -1) { //If not blocked
					chosen_piece = movable_pieces[i];
				}
			}
			// 6. If all blocked, move last blocked
			if (chosen_piece == null) {
				chosen_piece = blocked_pieces[blocked_pieces.length - 1];
			}
			break;
		default:
			break;
	}
	this.chosen_piece = chosen_piece;

	function contained(neighbourhood, stage) { //Checks if the neighbourhood is contained in a stage
		for (var i = 0; i < neighbourhood.length; i++) {
			for (var j = 0; j < neighbourhood[i].length; j++) {
				if (neighbourhood[i][j] != -1 && neighbourhood[i][j] != stage[i][j]) { //If they are in the neigh but don't coincide
					return false;
				}
			}
		}
		return true;
	}
}

Bot.prototype.movables = function(turn) { //Returns an array of the movable pieces of this
	var result = new Array();
	for (var i = 0; i < player[turn].length; i++) {
		if (!player[turn][i].end) {
			result.push(player[turn][i]);
		}
	}
	return result;
}

Bot.prototype.ordered_movables = function(turn) { //Returns an array of the movable pieces of this in order
	var temp = this.movables(turn); //Array of movable pieces
	for (var i = 0; i < temp.length; i++) {
		//temp[i].updateMovesToFinish();
		temp[i].reachesIn(temp[i].player == 0 ? 0 : board_size + 1);
	}

	temp.sort(function(a, b) { //Weak pieces have priority
		//Take minimum advance values
		var min_a = (a.direction == 1 ? Math.min(a.value, a.second_value) : a.value);
		var min_b = (b.direction == 1 ? Math.min(b.value, b.second_value) : b.value);
		if (min_a == min_b) { //If same minimum
			if (a.value != b.value) { //If different value, take weakest
				return a.value - b.value;
			}
			else if (a.direction != b.direction) { //If same value but different direction, take furthest from finish
				return b.moves_to_finish - a.moves_to_finish;
			}
			else { //If same value and direction, take closest to finish
				if (a.moves_to_finish == b.moves_to_finish) { //If same distance to finish, randomize
					return Math.random() - 0.5;
				}
				else {
					return a.moves_to_finish - b.moves_to_finish;
				}
			}
		}
		else { //If not same minimum, 1-4 over 2-3
			return min_a - min_b;
		}
	});
	return temp;
}


/**** TOUCH SETTINGS ****/
//Movements
var allow_click = false; //This value changes when the bot is "thinking"
var allow_back = false; //This allows to go only one hand back (turn ball)
ontouchstart = function(event) {
	var x = event.touches[0].clientX;
	var y = event.touches[0].clientY;
	if (allow_click) {
		commonStart(x, y);
	}
}
ontouchmove = function(event) {
	event.preventDefault();
}
onmousedown = function(event) {
	var x = event.clientX;
	var y = event.clientY;
	if (allow_click) {
		commonStart(x, y);
	}
}

function commonStart(x, y) { //Manage touch functions
	switch (menu) {
		case 0: //Sizes
			board_size = 5;
			sq_length = min/(board_size + 2 + board_margin); //Square length // RESIZE
			exit_margin = sq_length/12;
			turn = (chosen_turn == 2 ? Math.floor(Math.random()*2) : chosen_turn); //According to chosen_turn
			best_player = turn;
			createPieces();
			board_record = new Array();
			//saveThisBoard(); //Storage
			drawRival();
			menu = 1;
			break;
		case 1: //Rival
			if (exitClicked()) { //Main menu
				drawSizes();
				menu = 0;
				break;
			}
			if (x < canvas.width/2) { //Bot
				bot_chosen = true;
				drawLevel();
				menu = 2;
			}
			else { //Human
				bot_chosen = false;
				drawTurn(0); //"First hand"
				menu = 9;
			}
			break;
		case 2: //Level
			if (exitClicked()) { //Main menu
				drawSizes();
				menu = 0;
				break;
			}
			bot = new Bot(x < canvas.width/2 ? 0 : 1);
			drawTurn(1); //"Your side"
			menu = 10;
			break;
		case 9: //First hand
			if (exitClicked()) { //Main menu
				drawSizes();
				menu = 0;
				break;
			}
			turn = (x < canvas.width/3 ? 0 : (x < canvas.width*2/3 ? 1 : Math.floor(Math.random()*2)));
			// drawBoard();
			menu = 3;
			if (bot_chosen && turn != side) {
				allow_click = false;
				bot.simulate();
				setTimeout(function() { //Delay its painting
					bot.chosen_piece.draw(true);
				}, response_time/2);
				setTimeout(function() { //Delay its move
					commonStart(margin_x + sq_length*(1.5 + bot.chosen_piece.x), margin_y + sq_length*(1.5 + bot.chosen_piece.y));
					allow_click = true;
				}, response_time*3/2);
			}
			break;
		case 10: //Side
			if (exitClicked()) { //Main menu
				drawSizes();
				menu = 0;
				break;
			}
			side = (x < canvas.width/2 ? 0 : 1);
			drawTurn(0); //"First hand"
			menu = 9;
			break;
		case 3: //Board
			if (exitClicked()) { //Main menu
				if (confirm("Reset board?")) {
					window.location.replace("squadro_board_setter.html");
				}
			}
			if (menu == 0) {
				break;
			}
			//Discretization
			x = Math.floor((x - margin_x)/sq_length); // RESIZE (-1)
			y = Math.floor((y - margin_y)/sq_length); // RESIZE (-1)
			//Select appropiate piece and move it
			var chosen_piece = pieceOn(x, y);
			if (chosen_piece != null && chosen_piece.player == turn && !chosen_piece.end) { //If clicked ok, and correct player and not end
				copyPlayers(player, current_state); //Saves pieces so that can be retieved to go back one step
				chosen_piece.move();
				saveThisBoard(); //Storage
				allow_back = false;
				if (!end()) { //If not end of the game, switch turn and draw
					turn = (turn + 1)%2;
					drawBoard();
					// drawPieces();
					if (bot_chosen && allow_click) { //If bot && good turn, simulate its move and click
						allow_click = false;
						bot.simulate();
						setTimeout(function() { //Delay its painting
							bot.chosen_piece.draw(true);
						}, response_time/2);
						setTimeout(function() { //Delay its move
							commonStart(margin_x + sq_length*(1.5 + bot.chosen_piece.x), margin_y + sq_length*(1.5 + bot.chosen_piece.y));
							allow_click = true;
						}, response_time*3/2);
					}
				}
				else { //Else, save game and show replay
					board_record.push(turn);
					board_records.push(board_record);
					launchReplay(0); //Launches replay automatically (sets "replay" variable)
					//Local storage (save replay in localStorage)
					localStorage.setItem("replay", JSON.stringify(replay));
				}
			}
			else if (!end() && x == 0 && y == board_size + 1 && !allow_back && !bot_chosen) { //If not end && turn ball clicked (return ONE move) && no bot playing
				if (board_record.length > 1) { // Only when there has been at least one movement
					copyPlayers(current_state, player);
					turn = (turn + 1)%2;
					calculateMovesToFinish();
					drawBoard();
					drawPieces();
					// allow_back = true;
					board_record.pop();					
				}
			}
			if (x == board_size + 1 && y == board_size + 1) { //If code ball clicked
				var code = encodeBoard(false);
				try {
					copyToClipboard(code);
					var successful = document.execCommand('copy');
					alert("Board code copied to clipboard.");
				} catch (err) {
					alert("Sorry, couldn't copy the code to the clipboard. Here you have it raw:\n" + code);
				}
			}
			break;
		case 4: //Settings
			if (exitClicked()) { //Main menu
				drawSizes();
				menu = 0;
				break;
			}
			var radius = min/16;
			var color_radius = Math.min(radius, min/(3*colors_display.length));
			//Colors (row with colors, and current choice)
			for (var i = 1; i <= colors_display.length; i++) {
				if (distance(x, y, i*canvas.width/(colors_display.length + 1), canvas.height/5) <= color_radius && players_colors[(color_player + 1)%2] != colors_display[i - 1]) { //If color touched && not opponent's color
					chosen_color = i - 1;
					players_colors[color_player] = colors_display[chosen_color];
				}
			}
			//Player selected
			for (var i = 1; i <= 2; i++) {
				if (distance(x, y, i*canvas.width/3, canvas.height*2/5) <= radius) {
					color_player = i - 1;
					chosen_color = colors_display.indexOf(players_colors[color_player]);
				}
			}
			//Advantage
			//canvas.width/3 - radius, canvas.height/2 - radius/2, 2*radius, radius
			if (canvas.width/3 - radius <= x && x <= canvas.width/3 + radius && canvas.height*3/5 - radius/2 <= y && y <= canvas.height*3/5 + radius/2) { //Don't show advantage
				show_advantage = false;
			}
			else if (canvas.width*2/3 - radius <= x && x <= canvas.width*2/3 + radius && canvas.height*3/5 - radius/2 <= y && y <= canvas.height*3/5 + radius/2) { //Show advantage
				show_advantage = true;
			}
			//First turn
			for (var i = 1; i <= 3; i++) {
				if (distance(x, y, i*canvas.width/4, canvas.height*4/5) <= radius*2/3) {
					chosen_turn = i - 1;
				}
			}
			drawSettings();
			break;
		case 5: //Replay
			if (exitClicked()) { //Main menu
				if (confirm("Reset board?")) {
					window.location.replace("squadro_board_setter.html");
				}
			}
			if (menu == 0) {
				break;
			}
			var temp = replay_step;
			var jump = Math.floor(Math.sqrt(replay.length - 1)); //In a reasonable amount reaches the last
			var radius = min/20;
			if (distance(x, y, canvas.width/8, canvas.height/2 - radius) < radius) { //Rewind
				replay_step -= Math.min(jump, replay_step);
			}
			if (distance(x, y, canvas.width/8, canvas.height/2 + radius) < radius) { //Back
				replay_step -= 1;
			}
			if (distance(x, y, canvas.width*7/8, canvas.height/2 - radius) < radius) { //Fast forward
				replay_step += Math.min(jump, replay.length - 2 - replay_step);
			}
			if (distance(x, y, canvas.width*7/8, canvas.height/2 + radius) < radius) { //Forward
				replay_step += 1;
			}
			if (replay_step != temp) { //If any pressed
				turn = (turn + 1)%2;
				if (replay_step >= replay.length - 2) { //If last, turn is of loser
					replay_step = replay.length - 2;
					turn = (replay[replay.length - 1] + 1)%2;
				}
				else if (replay_step <= 0) { //If first turn, calculate back
					replay_step = 0;
					turn = (replay[replay.length - 1] + 1 + replay.length - 2)%2;
				}
				loadBoard(replay_step); //Load state
				drawReplayBoard();
			}
			if (distance(x + sq_length*1, y + sq_length*1, margin_x + 2*sq_length - sq_length/3, margin_y + 2*sq_length - sq_length/3) <= sq_length/3) { //Statistics button // RESIZE
				var x = canvas.width/4; var y = canvas.height/3; var w = canvas.width - 2*x; var h = canvas.height/2;
				drawStatistics(x, y, w, h);
				menu = 8;
			}
			if (distance(x - sq_length*1, y - sq_length*1, canvas.width - (margin_x + 2*sq_length - sq_length/3), canvas.height - (margin_y + 2*sq_length - sq_length/3)) <= sq_length/3) { //Code button
				var code = encodeBoard();
				try {
					copyToClipboard(code);
					var successful = document.execCommand('copy');
					alert("Board code copied to clipboard.");
				} catch (err) {
					alert("Sorry, couldn't copy the code to the clipboard. Here you have it raw:\n" + code);
				}
			}
			break;
		case 6: //Help
			if (exitClicked()) { //Main menu
				drawSizes();
				menu = 0;
				break;
			}
			break;
		case 7: //Notice
			if (exitClicked()) { //Main menu
				drawSizes();
				menu = 0;
				break;
			}
			break;
		case 8: //Statistics
			var temp = replay_step;
			var jump = Math.floor(Math.sqrt(replay.length - 1)); //In a reasonable amount reaches the last
			var radius = min/20;
			if (distance(x, y, canvas.width/8, canvas.height/2 - radius) <= radius) { //Rewind
				replay_step -= Math.min(jump, replay_step);
			}
			if (distance(x, y, canvas.width/8, canvas.height/2 + radius) <= radius) { //Back
				replay_step -= 1;
			}
			if (distance(x, y, canvas.width*7/8, canvas.height/2 - radius) <= radius) { //Fast forward
				replay_step += Math.min(jump, replay.length - 2 - replay_step);
			}
			if (distance(x, y, canvas.width*7/8, canvas.height/2 + radius) <= radius) { //Forward
				replay_step += 1;
			}
			if (replay_step != temp) { //If any of the two above
				turn = (turn + 1)%2;
				if (replay_step >= replay.length - 2) { //If last, turn is of loser
					replay_step = replay.length - 2;
					turn = (replay[replay.length - 1] + 1)%2;
				}
				else if (replay_step <= 0) { //If first turn, calculate back
					replay_step = 0;
					turn = (replay[replay.length - 1] + 1 + replay.length - 2)%2;
				}
				loadBoard(replay_step); //Load state
				var x = canvas.width/4; var y = canvas.height/3; var w = canvas.width - 2*x; var h = canvas.height/2;
				drawStatistics(x, y, w, h);
			}
			if (distance(x, y, canvas.width/2, canvas.height/10) <= sq_length/3) { //Replay board button
				drawReplayBoard();
				menu = 5;
			}
			break;
		default: //Any
			break;
	}
	
	function distance(x1, y1, x2, y2) { //Distance between two points
		return Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));
	}

	function exitClicked() { //Returns if EXIT has been clicked
		var margin = exit_margin;
		var side = min/10;
		var sq_width = sq_length*2/3;
		//var radius = (position == 0 ? side : sq_width)/2;
		//var x = (position == 0 ? canvas.width/2 : (position == 1 ? canvas.width - margin_x - 2*sq_length : margin_x + sq_length) + radius);
		//var y = (position == 0 ? 10 + radius : margin_y + 2*sq_length - radius);
		if ((menu == 1 || menu == 2 || menu == 4 || menu == 6 || menu == 7 || menu == 9 || menu == 10) && distance(x, y, canvas.width/2, canvas.height/10) <= side/2) { //Non-board
			return true;
		}
		else if ((menu == 3 || menu == 5) && distance(x - sq_length*1, y + sq_length*1, canvas.width - margin_x - 2*sq_length + sq_width/2, margin_y + 2*sq_length - sq_width/2) <= sq_width/2) { //Board // RESIZE
			return true;
		}
		else {
			return false;
		}
	}

	function copyPlayers(original, target) { //Copies all pieces from original to target
		for (var i = 0; i < target.length; i++) {
			target[i] = new Array(board_size);
			for (var j = 0; j < target[i].length; j++) {
				target[i][j] = new Piece(original[i][j].player, original[i][j].x, original[i][j].y, original[i][j].value);
				target[i][j].direction = original[i][j].direction;
				target[i][j].end = original[i][j].end;
				target[i][j].next_advance = original[i][j].next_advance;
			}
		}
	}

	function launchReplay(step) { //Launches replay
		createPieces();
		replay = board_records[board_records.length - 1]; //Loads last game (as a whole, not hand) saved
		replay_step = step;
		turn = (replay_step == 0 ? pieceMoved(replay).player : (turn + 1)%2); //Turn
		//show_advantage = true;
		loadBoard(replay_step); //Load state
		drawReplayBoard();
		menu = 5;
	}
}

function pieceOn(x, y) { //Returns the piece touched or null if none. This function saves memory with respect to loops
	if (0 < y && y < board_size + 1 && player[0][y - 1].x == x) {
		return player[0][y - 1];
	}
	else if (0 < x && x < board_size + 1 && player[1][x - 1].y == y) {
		return player[1][x - 1];
	}
}

function calculateMovesToFinish() { //Updates best player and returns the values [player[0], player[1]]
	var result = [0, 0];
	for (var i = 0; i < player.length; i++) {
		var total = 0;
		var independent = [];
		for (var j = 0; j < player[i].length; j++) {
			//player[i][j].updateMovesToFinish();
			player[i][j].reachesIn(player[i][j].player == 0 ? 0 : board_size + 1);
			total += player[i][j].moves_to_finish;
			independent.push(player[i][j].moves_to_finish);
		}
		var res = total; //All to return
		for (var j = 0; j < independent.length; j++) {
			res = Math.min(res, total - independent[j]); //Minimum of all "(All - 1) to return"
		}
		result[i] = res;
	}
	best_player = (result[0] == result[1] ? turn : (result[0] > result[1] ? 1 : 0));
	return result;
}

function end() { //Checks if the game has ended. Returns true/false
	var count = 0;
	for (var i = 0; i < player[turn].length; i++) {
		if (!player[turn][i].end) {
			count += 1;
		}
	}
	if (count == 1) {
		allow_click = true;
		return true;
	}
	else {
		return false;
	}
}

function pieceMoved(target) { //Returns the piece that moved at replay_step (next to move)
	for (var i = 0; i < player.length; i++) {
		for (var j = 0; j < board_size; j++) {
			if (target[replay_step + 1][i][j] > target[replay_step][i][j]) {
				return player[i][j];
			}
		}	
	}
}

function pieceInPosition(pl, coord) { //Returns Piece of reference piece
	for (var i = 0; i < player[pl].length; i++) {
		if (pl == 0 && player[pl][i].y == coord) {
			return player[pl][i];
		}
		else if (pl == 1 && player[pl][i].x == coord) {
			return player[pl][i];
		}
	}
}

function saveThisBoard() { //Records current board on board_record
	var temp_board = new Array(2); //For each player
	for (var i = 0; i < temp_board.length; i++) {
		temp_board[i] = new Array(board_size); //For the pieces
		for (var j = 0; j < temp_board[i].length; j++) {
			temp_board[i][j] = (i == 0 ? (player[0][j].direction == 1 ? player[0][j].x : (2*board_size + 2) - player[0][j].x) : (player[1][j].direction == 1 ? (board_size + 1 - player[1][j].y) : (board_size + 1) + player[1][j].y)); //The piece's position
		}
	}
	board_record.push(temp_board);
}

function loadBoard(step) { //Loads board from replay
	for (var i = 0; i < player.length; i++) {
		for (var j = 0; j < player[i].length; j++) {
			if (i == 0) { //Then, x's
				if (replay[step][i][j] < board_size + 1) { //Going
					player[i][j].x = replay[step][i][j];
					player[i][j].direction = 1;
				}
				else {
					player[i][j].x = 2*(board_size + 1) - replay[step][i][j];
					player[i][j].direction = -1;
				}
			}
			else { //Then, y's
				if (replay[step][i][j] < board_size + 1) { //Going
					player[i][j].y = board_size + 1 - replay[step][i][j];
					player[i][j].direction = 1;
				}
				else {
					player[i][j].y = replay[step][i][j] - board_size - 1;
					player[i][j].direction = -1;
				}
			}
		}
	}
}

function encodeBoard(end=true) { //Board to code
	var names = ["l", "b"]; //Left, bottom
	var code = "";
	for (var i = 0; i < board_record.length - (end ? 2 : 1); i++) {
		replay_step = i;
		var piece_moved = pieceMoved(board_record);
		code += names[piece_moved.player] + (piece_moved.player == 0 ? piece_moved.y : piece_moved.x);
	}
	return code;
}

function decodeBoard() {
	const urlParams = new URLSearchParams(window.location.search);
	var code = urlParams.get('code');
	if (code) { // If code introduced, set game
		loadCanvas();
		allow_click = true;
		//Choose size
		var size = 5;
		commonStart(canvas.width*2/3, canvas.height/2);
		//2 players
		commonStart(canvas.width*3/4, canvas.height/2);
		//First hand
		turn = (urlParams.get('turn') == "l" ? 0 : 1);		
		if (turn == 0) {
			commonStart(canvas.width/4, canvas.height/2);
		} else {
			commonStart(canvas.width*3/4, canvas.height/2);
		}
		//Gameplay
		// for (var i = 0; i < code.length/2; i++) {
		// 	var move = code.substring(2*i, 2*i + 2);
		// 	var piece_to_move = pieceInPosition((move[0] == "l" ? 0 : 1), parseInt(move[1]));
		// 	commonStart(piece_to_move.x, piece_to_move.y);
		// }
		//Set board
		for (var i = 0; i < code.length/2; i++) {
			var position = code.substring(2*i, 2*i + 2);
			var x, y, value, second_value, next_advance, direction, end;
			if (i/5 < 1) { // Left
				x = parseInt(position[1]);
				y = 6 - (i%5 + 1);
				direction = (position[0] == "l" ? 1 : -1); // l or L
				value = (i == 0 || i == 4 ? 1 : (i == 2 ? 2 : 3));
				second_value = (i == 0 || i == 4 ? 3 : (i == 2 ? 2 : 1));
				if (position[0] == "L") {value = second_value; next_advance = value};
				end = (direction == -1 && x == 0 ? true : false);
			}
			else { // Right
				x = (i%5 + 1);
				y = 6 - parseInt(position[1]);
				direction = (position[0] == "r" ? 1 : -1); // r or R
				value = (i%5 == 0 || i%5 == 4 ? 3 : (i%5 == 2 ? 2 : 1));
				second_value = (i%5 == 0 || i%5 == 4 ? 1 : (i%5 == 2 ? 2 : 3));
				if (position[0] == "R") {value = second_value; next_advance = value};
				end = (direction == -1 && y == 6 ? true : false);
			}
			player[Math.floor(i/5)][(Math.floor(i/5) == 0 ? 4 - i%5 : i%5)].x = x;
			player[Math.floor(i/5)][(Math.floor(i/5) == 0 ? 4 - i%5 : i%5)].y = y;
			player[Math.floor(i/5)][(Math.floor(i/5) == 0 ? 4 - i%5 : i%5)].direction = direction;
			player[Math.floor(i/5)][(Math.floor(i/5) == 0 ? 4 - i%5 : i%5)].value = value;
			player[Math.floor(i/5)][(Math.floor(i/5) == 0 ? 4 - i%5 : i%5)].second_value = second_value;
			player[Math.floor(i/5)][(Math.floor(i/5) == 0 ? 4 - i%5 : i%5)].next_advance = next_advance;
			player[Math.floor(i/5)][(Math.floor(i/5) == 0 ? 4 - i%5 : i%5)].end = end;
		}
		turn = (urlParams.get('turn') == "l" ? 0 : 1);		
		saveThisBoard();
		drawBackground();
		setTimeout(function() {
			drawBoard();
		}, 100);
	}
}

function copyToClipboard(text) { //Copy text to clipboard
   // Create new element
   var el = document.createElement('textarea');
   // Set value (string to be copied)
   el.value = text;
   // Set non-editable to avoid focus and move outside of view
   el.setAttribute('readonly', '');
   el.style = {position: 'absolute', left: '-9999px'};
   document.body.appendChild(el);
   // Select text inside element
   el.select();
   // Copy text to clipboard
   document.execCommand('copy');
   // Remove temporary element
   document.body.removeChild(el);
}

function htmlToCode() {
	var reds_list = ["R1", "R2", "R3", "R4", "R5"];
	var yellows_list = ["Y1", "Y2", "Y3", "Y4", "Y5"];
	var code = "";

	for (var i = 0; i < reds_list.length; i++) {
		letter = (document.getElementById("checkbox_" + reds_list[i]).checked ? "L" : "l");
		var radios = document.getElementsByName(reds_list[i]);
		for (var j = 0; j < radios.length; j++) {
			if (radios[j].checked) {
				if (radios[j].value == 6) { // Force "L"
					code += "L6";
				}
				else {
					code += letter + radios[j].value;
				}
			}
		}
	}
	for (var i = 0; i < yellows_list.length; i++) {
		letter = (document.getElementById("checkbox_" + yellows_list[i]).checked ? "R" : "r");
		var radios = document.getElementsByName(yellows_list[i]);
		for (var j = 0; j < radios.length; j++) {
			if (radios[j].checked) {
				if (radios[j].value == 6) { // Force "R"
					code += "R6";
				}
				else {
					code += letter + radios[j].value;
				}
			}
		}
	}

	code += "&turn=" + (document.getElementById("checkbox_turn").checked ? "r" : "l");
	window.location.replace("squadro_board_setter.html?code=" + code);
	decodeBoard();
}

onkeydown = function(event) {
	var key_pressed = event.keyCode;
	if (menu == 5 || menu == 8) {
		var radius = min/20;
		switch (key_pressed) {
			case 38: //Up
				commonStart(canvas.width/8, canvas.height/2 - radius);
				break;
			case 37: //Left
				commonStart(canvas.width/8, canvas.height/2 + radius);
				break;
			case 40: //Down
				commonStart(canvas.width*7/8, canvas.height/2 - radius);
				break;
			case 39: //Right
				commonStart(canvas.width*7/8, canvas.height/2 + radius);
				break;
		}
	}
}

decodeBoard();
</script>
</html>