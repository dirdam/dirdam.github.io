<!-- Copyright (c) Adrián Jiménez Pascual -  All rights reserved -->
<!-- This page and its content is protected under copyright and intellectual property laws.  -->
<!-- The content belongs to Adrián Jiménez Pascual, Tokio, Japan -->
<!-- All rights reserved. -->
<!--
  **  Lawbreakers will be reported to competent authorities and sentenced by the law   **
-->
<!--Copyright (c) Adrián Jiménez Pascual - http://www.ms.u-tokyo.ac.jp/~adri/ -->

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="shortcut icon" href="../Lasso_logo.ico"/>

<title>Adrï's Slizzle</title>

<script>

var size = 3;
var tile_radius;

var Tile = function(x, y, value, color) {
	this.x = x;
	this.y = y;
	this.value = value;
	this.color = color;
	this.real_x = tile_radius*this.x + x_space;
	this.real_y = tile_radius*this.y + y_space;
}

Tile.prototype.updateReal = function() {
	this.real_x = tile_radius*this.x + x_space;
	this.real_y = tile_radius*this.y + y_space;	
}

Tile.prototype.move = function(direc_x, direc_y) {
	this.x += direc_x;
	this.y += direc_y;
	this.real_x += tile_radius*direc_x;
	this.real_y += tile_radius*direc_y;
	if (this.x == size)
		this.x = 0;
	else if (this.x == -1)
		this.x = size-1;
	if (this.y == size)
		this.y = 0;
	else if (this.y == -1)
		this.y = size-1;
	this.updateReal();
}

Tile.prototype.draw = function() {
	drawSquare(this.real_x, this.real_y, this.color);
	drawSquareText(this.real_x, this.real_y, this.value);
}


function drawSquare(x, y, color) {
	context.fillStyle = color;
	context.fillRect(x, y, tile_radius, tile_radius);
	context.strokeRect(x, y, tile_radius, tile_radius);
}

function drawSquareText(x, y, text) {
	context.fillStyle = "black";
	context.font = tile_radius/2 + "px courier";
	context.fillText(text, x+tile_radius/2-context.measureText(text).width/2, y+tile_radius*2/3);
}

var board;
var x_space, y_space;
var background_color, normal_color, good_color, end_color;
onload = function() {
    canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    canvas.style.position = "absolute";
    canvas.style.left = 0;
    canvas.style.top = 0;
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    context = canvas.getContext("2d");

   	startGame();
}

function startGame() {
	background_color = "lightcyan";
	normal_color = "skyblue";
	good_color = "royalblue";
	end_color = "turquoise";

	

    context.lineWidth = 5;

    tile_radius = (Math.min(canvas.width, canvas.height)*25/30)/size;
    x_space = (canvas.width - tile_radius*size)/2;
    y_space = (canvas.height - tile_radius*size)/2;

    drawBackground(background_color);

    board = new Array(size); //Initialize the board
    for (var i = 0; i < board.length; i++) {
    	board[i] = new Array(size);
    	for (var j = 0; j < board[i].length; j++) {
    		board[i][j] = new Tile(i, j, j*size+i+1, normal_color);
    		board[i][j].draw();
    	}
    }

    randomize(board, 2*size*size);
}

function drawBackground(color) {
	context.fillStyle = color; //Fill background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = (color == "black" ? "white" : "black");
	context.font = canvas.height/32 + "px courier";
	context.globalAlpha = 0.5;
	context.fillText("\u00A9 Adr\u00ef", (canvas.width-context.measureText("\u00A9 Adr\u00ef").width)/2, canvas.height-canvas.height/30);
	context.globalAlpha = 1;

	context.font = "italic " + canvas.height/12 + "px courier";
	context.fillText("Adr\u00ef's Slizzle", (canvas.width-context.measureText("Adr\u00ef's Slizzle").width)/2, (canvas.height-size*tile_radius)/3);
}

function randomize(board, steps) { //randomizes the state of the board
	var tile_x, tile_y, rand_x, rand_y;
	for (var i = 0; i < steps; i++) {
		tile_x = Math.floor(Math.random()*size);
		tile_y = Math.floor(Math.random()*size);
		rand_x = Math.floor(Math.random()*3)-1;
		rand_y = Math.floor(Math.random()*3)-1;
		for (var j = 0; j < size; j++) {
			for (var k = 0; k < size; k++) {
				if (rand_x != 0) {
					if (board[j][k].y == tile_y) {
						board[j][k].move(rand_x, 0);
						if (board[j][k].x == j && board[j][k].y == k) {
			    			board[j][k].color = good_color;
			    		}
			    		else
			    			board[j][k].color = normal_color;
			    		board[j][k].draw();
					}
				}
				else if (rand_y != 0) {
					if (board[j][k].x == tile_x) {
						board[j][k].move(0, rand_y);
						if (board[j][k].x == j && board[j][k].y == k) {
			    			board[j][k].color = good_color;
			    		}
			    		else
			    			board[j][k].color = normal_color;
			    		board[j][k].draw();
					}
				}
			}
		}
	}
}

var touchedX, touchedY, tileX, tileY;
var allowedMove; //This is useful to restric the mousemove
onmousedown = function(event) {
	touchedX = event.pageX - x_space;
	touchedY = event.pageY - y_space;
	sharedStart();
	allowedMove = true;
}
onmousemove = function(event) {
	if (allowedMove) {
		touchedX = event.pageX - x_space;
		touchedY = event.pageY - y_space;
		sharedMove();
	}
}
onmouseup = function(event) {
	allowedMove = false;
	sharedEnd();
}

ontouchstart = function(event) {
	touchedX = event.touches[0].pageX - x_space;
	touchedY = event.touches[0].pageY - y_space;
	sharedStart();	
}
ontouchmove = function(event) {
	event.preventDefault();
	touchedX = event.changedTouches[0].pageX - x_space;
	touchedY = event.changedTouches[0].pageY - y_space;
	sharedMove();
}
ontouchend = function(event) {
	sharedEnd();
}

function sharedStart() {
	tileX = Math.floor(touchedX/tile_radius);
	tileY = Math.floor(touchedY/tile_radius);
}
function sharedMove() {
	var newX = Math.floor(touchedX/tile_radius);
	var newY = Math.floor(touchedY/tile_radius);
	if (newX != tileX) { //Move row
		for (var i = 0; i < board.length; i++) {
	    	for (var j = 0; j < board[i].length; j++) {
		   		if (board[i][j].y == tileY) {
		   			board[i][j].move(newX - tileX, 0);
					if (board[i][j].x == i && board[i][j].y == j) {
		    			board[i][j].color = good_color;
		    		}
		    		else
		    			board[i][j].color = normal_color;
		    		board[i][j].draw();
		   		}
		   	}
	    }
		tileX = newX;
	}
	if (newY != tileY) { //Move column
		for (var i = 0; i < board.length; i++) {
	    	for (var j = 0; j < board[i].length; j++) {
		   		if (board[i][j].x == tileX) {
		   			board[i][j].move(0, newY - tileY);
					if (board[i][j].x == i && board[i][j].y == j) {
		    			board[i][j].color = good_color;
		    		}
		    		else
		    			board[i][j].color = normal_color;
		    		board[i][j].draw();
		   		}
		   	}
	    }
		tileY = newY;
	}
}
function sharedEnd() {
	if (checkEnd()) {
		drawBackground("black");
		for (var i = 0; i < board.length; i++) {
	    	for (var j = 0; j < board[i].length; j++) {
	    		board[i][j].color = end_color;
	    		board[i][j].draw();
	    	}
	    }
		size++;
		setTimeout(startGame, 1000);
	}
}

function checkEnd() { //Checks if the board is ordered
	var result = true;
	for (var i = 0; i < board.length; i++) {
    	for (var j = 0; j < board[i].length; j++) {
	   		if (board[i][j].x != i || board[i][j].y != j) {
	   			result = false;
	   			break;
	   		}
	   	}
    }
    return result;
}

</script>